\chapter{Diseño del Software}
\label{diseno}

\small
\begin{flushright}
\emph{cita...}
\end{flushright}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Es imposible construir sin diseñar}

En este capítulo sobre diseño es casi inevitable comparar la ingeniería del software con la arquitectura. Sin embargo, todo depende del tamaño.

La caseta del perro la podemos hacer con unas cuantas tablas, quizás reciclando alguna cosilla de Ikea, un martillo (herramienta fundamental para toda obra en casa) y unos cuantos clavos. Si somos un poco ordenados, incluso cortaremos las tablas a medida y la pintaremos al final. Por muy orgullosos que estemos al terminar nuestra obra, casi seguro que no habremos realizado ningún esquema o plano para construir, simplemente con el material que tenemos nos hemos puesto a cortar tablas y clavar. Incluso, para una caseta un poco más grande donde guardar la herramienta en el jardín, lo más probable es que compremos una estructura hecha. Aunque seguramente tendremos en cuenta el tamaño y la forma, consultando planos a la hora de decidir el tipo de caseta, podemos montarlo nosotros mismos (por supuesto, con nuestro querido martillo). Si comparamos estos proyectos con desarrollos de software, lo parecido a lo descrito es que fueran pequeños trozos de código hechos para desechar (prototipos, alguna trasformación entre formatos, las prácticas de la carrera, etc.), con un único desarrollador/a donde lo que prima es el bajo coste económico y salir del paso lo más honradamente posible.

Ahora bien, cuando se trata de obra civil, los arquitectos deben de plasmar los elementos fundamentales en diferentes tipos de planos y otras especificaciones. Por ejemplo, a la hora de construir un edificio o vivienda, se detallarán en forma de planos las plantas, habitaciones, localización, etc. Además, se necesitarán vistas o aspectos de interés, por ejemplo, puede haber unos planos que muestren las conducciones del agua (fría y agua caliente sanitaria) en el edificio, otro para gas ciudad, otros que muestre la disposición del cableado para la electricidad y las comunicaciones (telefónicas, TV, radio y redes informáticas), el aire acondicionado, etc. Otras especificaciones incluirán los materiales a utilizar, calidades, luminosidad, etc. En su diseño y construcción son necesarios distintos gremios, y al final de la obra, será necesario pasar unos estándares de habitabilidad que garanticen los niveles de seguridad y comfort requeridos. Siguiendo con el símil de los proyectos informáticos, es en este tipo de proyectos en los que necesitamos la ingeniería del software. Habrá licitaciones, distintos equipos y/roles, se seguirán procesos definidos en donde se especificará la documentación necesaria, se pasarán distintos tipos de pruebas, se requerirá la aceptación por parte del cliente, y al final también se especificarán unas garantías y un mantenimiento.

En este capítulo, se proporciona una visión general de los distintos tipos de diseño y sus diferentes vistas en la ingeniería del software como puede ser la base de datos, el desarrollo con métodos estructurados u orientados a objetos, al igual que otros conceptos relacionados con el diseño como los patrones, frameworks, componentes o entornos específicos como los sistemas de tiempo real.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Objetivos}
\label{subsec:objetivos}

Los nuevos métodos de construcción de sistemas han dado al diseño un
papel esencial dentro del ciclo de vida de desarrollo del software.
Este capítulo tiene como objetivo fundamental introducir el concepto
de diseño y su importancia fundamental en la construcción y posterior
mantenimiento de un software de calidad. Como objetivos específicos
este capítulo pretende:

\begin{itemize}
  \item Introducir al lector en los conceptos fundamentales del diseño
del software, reflejando su importancia.
  \item Describir las actividades de la fase de diseño, así como los documentos y modelos
que en esta fase se generan para su documentación y evaluación.
  \item Mostrar los tipos básicos de diseño que se aplican al software en la
actualidad.
  \item Introducir y describir el propósito de la arquitectura del software.
  \item Presentar principios fundamentales de la calidad diseño del
software y sus propiedades.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}
\label{diseno:introduccion}


En la fase de diseño, tomando como punto de partida los requisitos, se pretende obtener una descripción de la solución software/hardware más adecuada que de soporte a dichos requisitos, teniendo no solamente en cuenta aspectos técnicos, sino también aspectos de calidad, coste y plazos de desarrollo. Es por tanto que en esta fase se pasa del \emph{qué} obtenido en la fase de requisitos, al \emph{cómo}, lo cual es el objetivo de la fase de diseño y en teoría, se deberían plantear varios diseños alternativos que cumplan con los requisitos, de modo que la elección final debería tomarse también de acuerdo a criterios de coste o esfuerzo de desarrollo, y criterios de calidad intrínsecos como por ejemplo la facilidad de mantenimiento.

Además con la fase de diseño, se entra en un a un ámbito más técnico ya que los productos del diseño son documentos y artefactos orientados a ingenieros del software, y no a la comunicación con los clientes o usuarios.
%
%En el análisis de requisitos, el objeto es el modelo del dominio, del problema real al que se quiere dar solución. Es decir, el \emph{qué}. Cuando se pasa a las
%actividades de diseño, el objeto de estudio pasa a ser el modelo de
%la solución, es decir, \emph{cómo} el software (o la combinación de
%software/hardware) va a servir como solución a los requisitos
%planteados.
Un ejemplo muy simple, en un sistema de facturación un requisito (el qué) podría ser que las facturas estuviesen ordenadas por código postal, con el objeto de que el sistema postal haga un precio favorable. En el cómo se encontrarían las decisiones de por ejemplo el diseño de los distintos  tipos de algoritmos de ordenación entre los que cumplan los requisitos (funcionales y no funcionales).

El estándar IEEE 610.12-1990 define  diseño como:\\

\begin{tabular}{|p{5in}|}
\hline
Definición \cite{IEEE-Std-glossary:90}\\
\hline El diseño del software tiene las dos siguientes acepciones:
\begin{itemize}
  \item El proceso para definir la arquitectura, los componentes, los
interfaces, y otras características de un sistema o un componente.
  \item El resultado de este proceso.
\end{itemize}\\
\hline
\end{tabular}\\


Esta definición concreta algunos de los elementos importantes en los
diseños software como es la arquitectura, es decir, es la descomposición de un sistema en sus componentes e interfaces. Estos conceptos se tratan en más profundidad en las siguientes secciones. Además, en lo referente a la estructura del propio proceso de diseño, este se descompone en dos subprocesos:
\begin{itemize}
  \item \textbf{Diseño de la arquitectura} o \textbf{diseño de alto nivel}: en el cual se
describe como descomponer un sistema y organizarlo en los diferentes
componentes (la arquitectura del software)% [IEEE 1471-00].
  \item \textbf{Diseño detallado}, el cual describe el comportamiento específico de dichos componentes de software.
\end{itemize}


%no obstante, en términos generales podemos decir que la
%arquitectura es la visión de alto nivel, que posteriormente se
%detalla hasta el nivel de componentes, que son los elementos
%modulares que representan la solución final.

%En el estándar de procesos de ciclo de vida IEEE/EIA 12207
%(``Software Life Cycle Processes'',
%el diseño del software consiste en dos actividades que encajan
%entre el análisis de los requisitos software y la
%construcción del software:

%
%In a standard listing of software life cycle processes such as
%IEEE/EIA 12207 Software Life Cycle Processes [IEEE12207.0-96],
%software design consists of two activities that fit between software
%requirements analysis and software construction:
%
%\begin{itemize}
%
%  \item Software architectural design (sometimes called toplevel design):
%describing software’s top-level structure and organization and
%identifying the various components.
%
%  \item Software detailed design: describing each component sufficiently to
%allow for its construction.
%
%\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conceptos fundamentales de diseño}
\label{subsec:conceptos}

En esta sección se cubren los conceptos fundamentales, tales como abstracción y
modularidad, propiedades y reglas se tiene que cumplir para
que los módulos se consideren modulares (descomposición de un sistema) y faciliten los criterios de calidad.

%
%SWEBOK:
%
%\begin{itemize}
%  \item Abstraction
%  \item Coupling and cohesion
%  \item Decomposition and modularization
%  \item Encapsulation/information hiding
%  \item Separation of interface and implementation
%  \item Sufficiency, completeness and primitiveness
%\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Abstracción}
\label{diseno:conceptos:abstraccion}

Como en el resto de los problemas de ingeniería, en el desarrollo de una solución de software, la solución se representará de forma abstracta con diferentes grados de detalle. Desde un nivel de abstracción alto y refinando la misma
hasta conseguir un nivel de detalle próximo a la implementación.
%
%Cada uno de los sucesivos niveles por los que pasará el
%diseño del sistema tendrá, por consiguiente, un nivel de
%detalle diferente, pasando del alto nivel de abstracción de los
%bocetos iniciales al bajo nivel de abstracción de los diagramas
%finales. Teniendo esto en cuenta se podría preguntar por
%qué no se pasa directamente al menor nivel de abstracción
%posible, que es el que permitiría codificar el software más
%rápidamente y se olvidan todos los demás, pero la respuesta
%es que las cosas no son tan sencillas. Explicaremos esto con más
%detalle a través de un ejemplo: Cuando se está comenzando el
%proyecto es muy importante determinar el esfuerzo y el tiempo de
%desarrollo que se va a invertir en el mismo, para hacer esto se
%utilizan unas técnicas de estimación de esfuerzo que se
%basan fundamentalmente en los requisitos iniciales del proyecto, los
%cuales se pueden acompañar de unos diagramas iniciales del
%sistema que pueden ayudar mucho en la realización de dichas
%estimaciones, pero los mismos se deben refinar mucho para que puedan
%ser de utilidad para construir el sistema. Según se vaya
%avanzando en el ciclo de vida del software el nivel de
%abstracción irá disminuyendo hasta que en la fase de
%construcción se obtenga en producto codificado, esto es, el
%nivel de abstracción de los artefactos desarrollados en la fase
%de planificación será mayor que el de los de la fase de
%análisis que, a su vez, será mayor que el de los de la fase
%de diseño, los cuales ya estarán muy próximos al
%código.
%
Se pueden diferenciar tres tipos fundamentales de abstracciones en
el desarrollo de un sistema:

\begin{itemize}

  \item \textbf{Abstracción de datos}. Un nombre asignado a un objeto que
  incluye un conjunto de datos. La abstracción \emph{Cliente}, por
  ejemplo incluirá todos los datos que se hayan considerado útiles para un cliente,
  tales como nombre, dirección, teléfono, etc.

  \item \textbf{Abstracción de control}. Define a un
  sistema de control de un software sin describir los datos internos que
  permiten operar al mismo. Por ejemplo una abstracción de control
  típica es el semáforo que permite
  coordinar el funcionamiento de un sistema operativo.

  \item \textbf{Abstracción procedimental}. Es aquella que permite referirse
  al conjunto de pasos que constituyen un proceso determinado.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Componentes e interfaces}
\label{diseno:conceptos:componentesInterfaces}

El objetivo del diseño es la especificación de
componentes, módulos o fragmentos software tales como clases, y cómo se comunican
sin describir sus detalles internos. Estas comunicaciones
se expresan mediante la especificación de las operaciones que los
componentes exponen para que otros puedan usarlos (interfaces).
% El
%concepto de componente e interfaz no es exclusivo de la ingeniería
%del software, por ejemplo, en la ingeniería electrónica, los diseños
%se basan en componentes (circuitos) que tienen interfaces bien
%definidas.
\\
\begin{tabular}{|p{5in}|}
\hline
Definición\\
\hline Un componente es una parte funcional de un sistema
que oculta su implementación proveyendo su realización a través de un conjunto de
interfaces.
\\\hline
\end{tabular}\\

Por tanto, un componente es generalmente un elemento reemplazable y autocontenido dentro de una arquitectura bien definida que se comunicará con otros componentes a través de interfaces.


\begin{tabular}{|p{5in}|}
\hline
Definición\\
\hline Una interfaz describe la frontera de comunicación
entre dos entidades software, es decir, de cómo un
componente interactua con otros componentes.\\
\hline
\end{tabular}\\


Nótese que el término interfaz se utiliza también con otros
significados que nada tienen que ver, como el caso de la interfaz de
usuario.

%También algunos lenguajes de programación como Java tienen
%un elemento sintáctico para definir interfaces (en el caso de Java,
%es interface). No obstante, aquí interfaz se usa para describir
%especificaciones de componentes, en un sentido general del diseño.

%
%%% AÑADIR ALGO MÁS Y MEJORAR
%Al igual que en el hardware, la idea de generar sistemas a base de
%ensamblar componentes software ha dado lugar a la \emph{ingeniería
%del software basada en componentes}. Siguiendo esta metodología y
%adheriéndose a especificaciones concretas, debería ser posible
%combinar componentes de distintas empresas para generar sistemas más
%rápidamente, actualizar componentes, etc..

%
% Es también muy importante resaltar que los componentes
%representan un concepto de carácter económico fundamental en
%la Ingeniería del Software. La idea general es que si el
%software se divide adecuadamente en componentes, se podrían
%reutilizar (quizá revender o compartir) componentes hechos para
%una aplicación en otras. También se podría escoger
%entre implementaciones (componentes) diferentes para una misma
%especificación (interfaz), generando un tipo de competencia en
%la oferta de software.
%
%Por ello, el denominado ``diseño basado en componentes''
%enfatiza la posibilidad de reutilización, que en la mayoría
%de las ocasiones no es un requisito explícito en los
%desarrollos software. Esa reutilización puede ser también
%interna (dentro del mismo proyecto), generando ahorros en el
%esfuerzo necesario para el desarrollo.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Descomposición y modularización}
\label{diseno:conceptos:modularizacion}

La descomposición y modularidad son consecuencia de la complejidad
de los problemas, y de la necesidad de hacer manejable el desarrollo de la solución de los mismos.  Para abarcar el desarrollo del
sistema complejo, el problema se divide en subproblemas más fácilmente manejables, que integrados formarán la solución al sistema completo. Más formalmente, B. Meyer~\cite{Meyer99} ha definido una serie de propiedades para
evaluar la modularidad:

\begin{description}
  \item[Descomposición] Esta propiedad permite definir componentes de alto
  nivel en otros de bajo nivel. Esta descomposición puede ser recursiva, es decir, aplicando la máxima de divide y vencerás.

%hasta que los módulos puedan ser desarrollados individualmente.
%por ejemplo para que la codificación cada modulo
%sea independiente y se puedan distribuir las tareas entre distintos
%equipos, localizaciones, etc.

  \item[Composición] La composición se puede ver como el problema
inverso a la descomposición. Un
modulo de programación preserva la composición modular si facilita
el diseño de elementos de programación que se pueden ensamblar entre
sí para desarrollar aplicaciones. Un ejemplo de composición
modular son los componentes COTS (\emph{Commercial-off-the-Shelf} -
Componentes ya desarrollados), que contienen un conjunto de
elementos de programación que se reutilizan en infinidad de
aplicaciones. La composición modular está vinculada directamente al
factor de calidad de reutilización: el objetivo es buscar mecanismos
que permitan diseñar elementos de programación que respondan a
tareas y funciones bien definidas, y que sean reutilizables en una
gran diversidad de contextos.

  \item[Comprensión] Un método de programación preserva la
comprensión modular si facilita el diseño de elementos de
programación que se pueden interpretar fácilmente sin tener que
conocer el resto de los módulos. Un aspecto fundamental de la
comprensión es la documentación y en el caso particular de los
componentes en la ingeniería del software basada en componentes, la
gestión e indexación de los mismos para facilitar su reutilización.

  \item[Continuidad] La continuidad se refiere a que un pequeño cambio
en la especificación debe conllevar en la implementación un cambio
igualmente pequeño. Una de las leyes de Lehman (ver Seccion ???),
afirma que si un proyecto esta ``vivo'', inevitablemente
evolucionará y cambiará. Por tanto, es importante que pequeños
cambios en los requisitos repercutan en un número limitado y
localizado de módulos. Un ejemplo de continuidad se da cuando al
utilizar variables constantes en vez de utilizar las constantes en
distintos puntos del sistema; de esta manera, cuando se necesite
cambiar el valor de la constante, este cambio se hará en un único
lugar en vez de en multiples puntos del sistema.

  \item[Protección] Esta propiedad consiste en que los efectos de las
anomalías de ejecución queden confinados al módulo donde se produjo
el error, o que se propaguen a un número limitado de módulos con los
que interactúa directamente. Un ejemplo de protección se da en la
validación de datos introducidos por parte del usuario, dicha
validación debería hacerse en los módulos que tratan la entrada, sin
permitir que los datos incorrectos se propaguen a aquellos módulos
donde se procesan.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Tabla: Reglas de Meyer Modularidad %%%


\begin{tabular}{|p{5in}|}
\hline
Reglas de Meyer para la modularidad.\\
\hline
Meyer~\citeyear{Meyer99} propuso 5 reglas que hacen referencia a la conexión
entre programas y a la interacción entre módulos, que se deben
preservar para garantizar la modularidad.
\begin{itemize}
  \item \textbf{Correspondencia directa}. Debe existir una relación coherente (correspondencia) entre el dominio del problema y la solución.
%
%Esta regla afecta a las propiedades de: (i) continuidad,
%ya que si hay una correspondencia directa entre el dominio del
%problema y la estructura de la solución, es facilita la evolución y
%modificación de los requisitos; y (ii) a la descomposición, el
%análisis de la estructura del dominio, ayuda a crear una apropiada
%descomposición modular; (iii) y en menor medida a la protección
%evitando la propagación de errores entre los módulos.
%
  \item \textbf{Limitación en el número de interfaces}. Se debe reducir al máximo el número de comunicaciones entre módulos.
%
  \item \textbf{Limitación del tamaño de las interfaces}. Además el número de comunicaciones entre los módulos de la regla anterior, se debe limitar al mínimo el tamaño de la información intercambiada entre módulos.
%
  \item \textbf{Facilidad de reconocimiento de las interfaces}. La comunicación entre módulos tiene que ser pública y reconocible, es decir, las interfaces deben ser explícitas facilitando así el diseño de la interfaz.
%
%  La regla más importante de la limitación de
%interfaces nos recomienda que cualquier módulo se comunique con la
%mínima cantidad posible de módulos. Si dos módulos deben comunicarse
%necesariamente, hay que limitar al máximo la cantidad de información
%intercambiada.
%Así, se facilita que cualquier
%necesidad de comunicación entre módulos detectada en la etapa de
%diseño se refleje en el diseño de una interfaz, de manera que se
%preserva la composición y la descomposición. Esta identificación
%también facilita que se detecten los módulos que se pueden ver
%afectados por un cambio en las especificaciones del problema --se
%preserva la continuidad. Finalmente, facilita también la comprensión
%del problema porque se pueden identificar las dependencias entre
%módulos fácilmente.
%
  \item \textbf{Ocultación de la información}. Se debe obtener una modularización que aísle los cambios al menor número posible de módulos. En la etapa de diseño de un módulo, se especifica el conjunto de  propiedades del módulo que constituirán la información a la cual tendrán acceso los otros módulos. Dichas propiedades públicas compondrán la interfaz del módulo~\cite{Parnas:1972}.
%
%Estas propiedades las podemos dividir en dos tipos: (i) Las
%\textit{propiedades públicas} son aquellas que los usuarios de
%nuestro módulo pueden consultar y modificar directamente. En cambio,
%(ii) las \textit{propiedades privadas} son aquéllas a las cuales se
%acceden desde el mismo modulo. Es importante identificar las
%propiedades públicas y privadas de los módulos porque, justamente,
%las propiedades públicas son las que constituirán la interfaz del
%módulo y, por lo tanto, serán las que los otros módulos (objetos)
%deberán conocer. Esta regla ayuda a preservar el principio de
%continuidad: si un cambio en la especificación del problema sólo
%afecta a las propiedades privadas de un módulo, no será necesario
%revisar ni modificar el código del resto de los módulos. Cuanto
%menor es la parte pública de un módulo, más probable es que los
%cambios de especificaciones tan sólo afecten a las propiedades
%privadas, cosa que facilita tanto la reutilización de los módulos
%como su mantenimiento.
%
\end{itemize}\\
\hline
\end{tabular}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Medición de la modularidad}
\label{diseno:subsec:modularidad}

Las propiedades y reglas mencionadas anteriormente buscan que las
dependencias entre módulos sean mínimas. La modularidad se suelen medir
con los conceptos de acoplamiento y cohesión definidos a
continuación.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Acoplamiento}
\label{diseno:subsubsec:acoplamientodir}

El acoplamiento mide el grado de interconexión
existente entre los módulos en los que se ha dividido el diseño de
la arquitectura de un sistema software.

El objetivo es conseguir un acoplamiento bajo entre módulos, también llamado débil, genera sistemas más fáciles de entender, mantener y modificar, ya que cambios en la interfaz de un componente afectarían un número reducido de cambios en otros componentes. Por tanto, debemos acercarnos al mínimo número de relaciones posibles entre todos los
módulos en la que un módulo sólo se comunicaría con otro
módulo, es decir, $(n - 1)$ comunicaciones entre módulos, donde $n$ es el número de módulos de un sistema (figura~\ref{fig:diseno:conceptos:acoplamiento}(a)). Por el contrario debemos alejarnos del máximo máximo número de conxiones,  $(n \dot (n - 1) / 2)$, donde se produce un acoplamiento fuerte (figura~\ref{fig:diseno:conceptos:acoplamiento} (b)).

%
%Esto hace que los módulos sean independientes e indica un
%sistema bien dividido

%\begin{figure}
%\begin{center}
%    \epsfig{file=./5Diseno/figs/acoplamiento.eps, width=9cm}
%\end{center}
%\caption{Acoplamiento débil y fuerte}
%\label{fig:diseno:conceptos:acoplamiento}
%\end{figure}


\begin{figure}%[htbp]
\begin{tabular}
{|p{213pt}|p{213pt}|} \hline
\centerline{\includegraphics[width=2in,height=1.29in]{./5Diseno/figs/acoplamientoDebil.eps}}
\par &
\centerline{\includegraphics[width=2in,height=1.25in]{./5Diseno/figs/acoplamientoFuerte.eps}} \par  \\
\hline
\end{tabular}
\caption{(a) Acoplamiento débil; (b) Acoplamiento fuerte}
\label{fig:diseno:conceptos:acoplamiento}
\end{figure}


Además del número de conexiones, el grado de acoplamiento puede depender de la la complejidad de las conexiones, los lugares donde se realicen las referencias a los módulos, el volumen y tipo de datos que intercambian los módulos.

%Existen por tanto diferentes tipos posibles de acoplamiento:
%
%
%\begin{description}
%
%\item [Acoplamiento de Datos]. El acoplamiento de datos representa un
%grado bajo de acoplamiento entre módulos en el que los módulos
%únicamente se pasan una lista simple de argumentos uno a uno.
%
%\item [Acoplamiento de Marca]. Se trata de una variante un poco
%más compleja del acoplamiento de datos en la que lo que se pasa por
%la interfaz entre los módulos no es únicamente argumentos simples
%sino que es toda una parte de la estructura de los datos.
%
%\item [Acoplamiento de Control]. El acoplamiento de control
%representa un grado de acoplamiento que comienza a ser considerable
%y que además es muy usual que se produzca cuando se diseñan
%sistemas, consiste en la variable que controla el funcionamiento de
%un módulo se obtiene de otro módulo con el que el mismo tiene
%interfaz, pudiéndose tratar de un módulo superior o subordinado.
%
%\item [Acoplamiento Externo]. El acoplamiento externo, que puede
%generar un alto grado de acoplamiento y que deberá ser evitado en la
%medida de lo posible, aunque nunca se podrá hacer totalmente, se
%refiere a la utilización de datos por un conjunto de módulos que los
%toman de algún dispositivo externo al software.
%
%\item [Acoplamiento Común]. El acoplamiento común también
%puede generar un alto grado de acoplamiento, consiste
%fundamentalmente en que un conjunto de módulos toman los datos
%procedentes de una parte específica del sistema.
%
%\item [Acoplamiento de Contenido]. Se trata del grado más alto de
%acoplamiento existente y debe evitarse en todos los casos. Se
%produce cuando un módulo hace uso de datos o información de control
%que se encuentran en otro módulo.
%
%\end{description}


%\begin{itemize}
%  \item Acoplamiento de datos. Solamente se pasan datos entre los módulos o
%componentes.
%  \item Acoplamiento de marca (stamp coupling). Se usa una estructura de datos para
%pasar información de un componente a otro, y es la estructura
%misma lo que se pasa a través de la interfaz.
%  \item Acoplamiento de control. Se caracteriza por el paso de control entre módulos. Dado P y
%Q. Si P invoca a Q: Q contesta datos Q contesta datos mas
%instrucciones
%  \item Acoplamiento externo. Los módulos están ligados a un entorno
%externo al software. Ej. La E/S acopla un módulo a dispositivos,
%formatos y protocolos de comunicación. Este acoplamiento es
%esencial pero deberá estar limitado a unos pocos módulos.
%\end{itemize}



%\begin{figure}[htbp]
%\centerline{\includegraphics[width=3.85in,height=2.88in]{./5Diseno/figs/d3.eps}}
%\caption{Ejemplo de DFD (rehacer la figura!!)}
%\label{fig3}
%\end{figure}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Cohesión}
\label{diseno:cohesion}

Otro aspecto fundamental del diseño, también derivado de una
concepción modular del mismo, es la cohesión. Un subsistema o módulo
tiene un alto grado de cohesión si mantiene unida funcionalidad común. Por ejemplo, un clase dedicada al manejo de fechas, tiene sólo operaciones relacionadas con las fechas y no por ejemplo a la gestión de cumpleaños.

Por tanto, el objetivo es diseñar módulos robustos y
altamente cohesionados cuyos elementos estén fuerte relacionados
entre si buscando la \textbf{cohesión funcional}, en la que un módulo realiza operaciones bien definidas y suscritas a una funcionalidad requerida facilitando las propiedades compresibilidad, reutilización.

Cuando los módulos agrupan funcionalidad por otros motivos que no sean funcionalidad la cohesión no será optima. Por ejemplo, \emph{cohesión secuencial} en la que la funcionalidad se agrupa por la secuencia de ejecución, \emph{cohesión por comunicación} al compartir los mismos datos, o la peor de todas, \emph{cohesión por coincidencia} agrupando funcionalidad sin orden (cajón desastre).

%Se diferencian distintos tipos de cohesión:
%\begin{itemize}
%  \item Cohesion funcional. En la que un módulo realiza operaciones bien definidas y suscritas a una funcionalidad requerida facilitando las propiedades compresibilidad, reutilización. Los elementos contribuyen a la ejecución de una tarea relacionada con el problema.
%  \item Cohesion secuencial. Agrupa procedimientos en los que uno proporciona la entrada al siguiente. Puede no ser bueno de cara a la reutilización
%y puede contener actividades que no se suelen utilizar juntas.
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=3.54in,height=0.65in]{./5Diseno/figs/d4.eps}}
%%\caption{Tablas de decision}
%%\label{fig4}
%%\end{figure}
%  \item Cohesión Comunicación. El criterio para unir las actividades es si acceden o
%manipulan los mismos datos. El orden, a diferencia de la cohesión
%secuencial, no es importante.
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=4.26in,height=1.49in]{./5Diseno/figs/d5.eps}}
%%\caption{. Modelo E/R (anadir un ejemplo con atributos)}
%%\label{fig5}
%%\end{figure}
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=3.20in,height=1.73in]{./5Diseno/figs/d6.eps}}
%%\caption{Ejemplo de diagrama de estructura de datos} \label{fig6}
%%\end{figure}
%\item Cohesion Procedimental. Composición de partes de funcionalidad que se
%organizan secuencialmente pero que, por otra parte, tienen poca
%relación entre si. Mal mantenimiento.
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=4.38in,height=1.47in]{./5Diseno/figs/d7.eps}}
%%\caption{Cohesion Procedimental} \label{fig7}
%%\end{figure}
%%\item[]
%\item Cohesion Temporal. Las operaciones que se realizan durante la misma fase de la ejecución del programa se mantienen unidas. Mal mantenimiento.
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=4.41in,height=1.25in]{./5Diseno/figs/d8.eps}}
%%\caption{Cohesion Temporal} \label{fig8}
%%\end{figure}
%\item Cohesión lógica. Agrupa una serie de actividades en la misma
%categoría general. La actividad a ejecutar se determina normalmente
%por un parámetro de entrada.
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=3.02in,height=1.52in]{./5Diseno/figs/d9.eps}}
%%\caption{Cohesión lógica} \label{fig9}
%%\end{figure}
%\item[Cohesión por coincidencia] Cuando se relacionan utilidades que no se pueden ser
%situadas de forma lógica en otras unidades cohesivas. Evidentemente,
%es la peor cohesión que se puede dar.
%
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=4.17in,height=1.42in]{./5Diseno/figs/d10.eps}}
%%\caption{Cohesión por coincidencia} \label{fig10}
%%\end{figure}
%\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Diseño arquitectura %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Arquitectura de sistemas}
\label{diseno:arquitectura}

Con los criterios comentados anteriormente, podemos definir más formalmente el concepto de arquitectura y aunque es un concepto muy amplio, el estándar IEEE 1471-2000 (\emph{IEEE Recommended Practice for Architectural Description of Software-Intensive Systems}), también publicado como estándar ISO/IEC 42010:2007, definen la arquitectura del software como un acuerdo de mínimos.


\begin{tabular}{|p{5in}|}
\hline
Definición (IEEE 1471-2000)\\
\hline La organización fundamental de un sistema plasmado en sus
componentes, las relaciones entre estos y con el entorno, y los
principios guiando su diseño e implementación.\\
\hline
\end{tabular}

Este es el primer estándar sobre arquitectura software y como su
nombre indica, define las practicas recomendadas, que siguiendo la
terminología IEEE, no es normativa, es decir, su adopción e
interpretación son responsabilidad de las organizaciones que las
implementan. Por tanto el estándar sólo describe un marco general en
el que aborda los siguientes puntos:

\begin{itemize}
  \item Identificación a todas las personas interesadas en el
proyecto y sus intereses.
  \item Selección e identificación de los puntos de vista para los
distintos intereses.
  \item Documentación de las vistas de la arquitectura que
satisfacen los puntos de vista
  \item Documentación las inconsistencias entre vistas
  \item Proporcionar la base para las decisiones arquitecturales.
\end{itemize}

Como se ha comentado anteriormente, debido a la complejidad de un
sistema software en cuanto a la especificación, diseño y
construcción, requiere diferentes perspectivas, la diseño
arquitectural nos permite organizar diferentes puntos de vista y
controlar el desarrollo de un sistema mediante organización del
sistema, evaluación y selección de tanto los aspectos estructurales
para cumplir con los requisitos funcionales, como con los aspectos
no estructurales de la arquitectura para los aspectos no funcionales
como por ejemplo rendimiento, capacidad de adaptación,
reutilización, etc.

Por vistas, se refiriere por ejemplo a la vista estructural con sus
componentes, interfaces y relaciones. En el diseño de un sistema, se
necesitan diferentes vistas para modelar las diferentes partes
constituyentes de un sistema, descripción de los subsistemas,
componentes y las interrelaciones entre ellos. Las diferentes
aproximaciones al diseño pueden describir los sistemas con distintas
técnicas y dependiendo del tipo de proyecto, podríamos considerar:

\begin{itemize}
  \item Arquitectura funcional, describiendo las distintas funciones del
sistema. Es importante destacar que el criterio de división en
subsistemas puede ser de dos tipos:

\begin{itemize}
  \item Criterios funcionales de usuario, en los cuales la
descomposición agrupa funcionalidades (reflejadas en
los requisitos funcionales). Por ejemplo, en una aplicación para la
gestión de un campus virtual, podrían considerarse un subsistema de aula
virtual (conteniendo la funcionalidad de los alumnos y profesores en
su interacción), otro subsistema de administración (con las
funcionalidades de registro, matrícula y gestión administrativa), y
quizá otro de gestión de contenidos (agrupando las funcionalidades
de edición y validación de los materiales o recursos educativos
\textit{on-line}).
  \item Criterios transversales a las funcionalidades. Estos incluyen todos
los aspectos que no son específicos de ciertos grupos funcionales.
Por ejemplo, un subsistema de seguridad, que incluye, siguiendo el
ejemplo, todas las funciones de control de acceso y derechos de
acceso, o un subsistema de persistencia, que agrupa todos los
servicios relacionados con el almacenamiento de los datos en
soportes persistentes como discos duros. De hecho, un gestor de
bases de datos puede utilizarse como subsistema de persistencia en
casi cualquier tipo de aplicación.
\end{itemize}

  \item Estilo arquitectónicos que implementan la arquitectura
funcional, por ejemplo describiendo las capas que lo componen,
componentes y como interactúan entre ellos.

  \item La arquitectura de la base de datos (ver sección \ref{})

 \item Arquitectura hardware y de red que componen el sistema.

\end{itemize}


Por tanto, la arquitectura trata de definir la estructura interna
del software, pero deteniéndose en el nivel de los componentes e
interfaces que afectan a la interrelación que se está especificando,
sus protocolos de comunicación y sincronización y distribución
física del sistema, pero no trata, el diseño detallado o algoritmos.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Estilos arquitectónicos}
%\label{subsubsec:estilos}

Existen distintas formas de unir los distintos componentes de las
arquitecturas de sistemas software, dependiendo de cómo son
divididos los distintos módulos y como estos se comunican. Los
estilos arquitectónicos se suelen describir como patrones con sus
ventajas y desventajas. A continuación se clasifican los estilos
arquitectónicos más comunes:


\begin{itemize}

  \item Filtro-tubería (\emph{Pipe-Filter}) o procesamiento por lotes.
  Se basan en flujos de datos, donde un componente transforma una entrada en una salida que a su vez es la entrada para otro componente (figura \ref{fig:diseno:arquitectura:pipeFilter}) . Esta arquitectura es típica de \textit{mainframes}, donde mucho procesamiento se hace por lotes y no existe la interacción con el usuario. Por ejemplo, en un sistema de facturación en COBOL, distintos módulos van transformando ficheros hasta conseguir las facturas finales.

\begin{figure}%[htbp]
\begin{center}
    \epsfig{file=./5Diseno/figs/pipeFilter.eps, width=9cm}
\end{center}
\caption{Estilo arquitectónico de procesamiento por lotes}
\label{fig:diseno:arquitectura:pipeFilter}
\end{figure}

  \item Orientación a Objetos. En este estilo, la arquitectura se
representa mediante grafo cuyos nodos son objetos y los arcos son
los conectores que comunican los objetos mediante los métodos. Este
estilo se ve en detalle más adelante en este capítulo.

  \item Arquitectura basada en eventos (Invocación implícita) . Los
componentes anuncian sus eventos y otros registran su interés en ser
notificados cuando ocurren ciertos eventos causando la invocación de
procedimientos en otros componentes. Por ejemplo, en las interfaces de usuario, eventos como el pulsar el ratón, disparará la ejecución de ciertas funciones

  \item Arquitecturas basadas en capas. Los componentes del sistema están
  organizados jerárquicamente por capas, como si fuera un cebolla donde las capas superiores acceden a los servicios de las capas inferiores. Por ejemplo, el diseño de un sistema operativo (figura \ref{fig:diseno:arquitectura:capas}).

\begin{figure}%[htbp]
\centerline{\includegraphics[width=2.5in]{./5Diseno/figs/arquitecturaCapas.eps}}%[width=3.49in,height=1.64in]
\caption{Ejemplo simplificado de arquitectura en capas de un sistema operativo}
\label{fig:diseno:arquitectura:capas}
\end{figure}

  \item Sistemas basados en repositorios. En este estilo, existe una
  estructura central de datos y componentes independientes que acceden a los datos (figura \ref{fig:diseno:repositorios})

\begin{figure}%[htbp]
\centerline{\includegraphics[width=2.5in]{./5Diseno/figs/d47.eps}}
\label{fig:diseno:repositorios} \caption{Ejemplo arquitectura basada en repositorios}
\end{figure}


  \item Control de Procesos. En los procesos de control como mantenimiento de temperaturas o niveles de líquidos, se suele utilizar el estilo donde el bucle de control (\textit{feedback loop}) podría ir con la entrada o después del proceso (figura \ref{fig:diseno:arqControl}).

\begin{figure}[htbp]
\centerline{\includegraphics[width=2.5in]{./5Diseno/figs/arquitecturaControl.eps}}
\label{fig:diseno:arqControl}
\caption{Ejemplo de arquitectura de control}
\end{figure}

  \item Procesos distribuidos. La distribución de la funcionalidad se divide
  en diferentes procesos generalmente distribuidos en diferentes máquinas. A su vez se pueden diferenciar en tareas \textit{cliente-servidor}, por ejemplo la Web, y arquitecturas \emph{par a par} (\textit{Peer-to-Peer}, P2P) por ejemplo con sistemas de distribución de ficheros, TV o voz sobre IP (figura \ref{fig:diseno:arqDistribuida}).

\begin{figure}%[htbp]
\begin{tabular} {p{190pt}p{190pt}}
\centerline{\includegraphics[width=2in]{./5Diseno/figs/d49.eps}}
\par &
\centerline{\includegraphics[width=2in]{./5Diseno/figs/d50.eps}} \par  \\
\end{tabular}
\label{fig:diseno:arqDistribuida} \caption{(a) Cliente-servidor; (b) \emph{Peer-to-peer}}
\end{figure}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Lenguajes arquitectónicos}
\label{diseno:subsubsec:marcos}

Los lenguage arquitectonicos (\textit{Aquitecture Description
Language -- ADL}) son lenguajes para describir arquitecturas
software, es decir, sus componentes, conectores y enlaces (comunicación) entre
ellos. Cuando una arquitectura se describe
mediante estos lenguajes, es posible tener herramientas para la
verificación de la arquitectura y el prototipado rápido. Existen
ADLs de propósito general y otros de dominio específico
(DSSA--Domain-Specific Software Architectures).
Un ejemplo de lenguaje arquitectural es ACME, aunque también puede considerarse UML (de mucho más extendido uso hoy día) para representar arquitecturas.



%¿Pondriaís otros como Open Group, MODAF/DoDAF Architectural Model
%(MAF) y SysML
%
%A conspicuous disconnect exists between a MODAF/DoDAF Architectural Model
%(MAF) and any subsequent Systems Engineering modeling activities. MAF
%permits the modeling of `system-of-systems' and they both facilitate the
%capture of the high-level properties of a system's interfaces. However, how
%is this critical information communicated to an organization contracted to
%develop the real system? How does an organization ensure traceability from
%MAF artifacts and any subsequent Systems Engineering artifacts? In addition
%to heavyweight and lightweight mapping, SysML offers bridges that provide
%traceability between artifacts in MAF and any subsequent system
%specification. The concepts used by the different languages are examined as
%well as mapping from MAF to SysML. This presentation explores allocation and
%requirements traceability. Due to the inherent extensibility of a UML-based
%model, properties not prescribed by MAF (`Risk') can be added to a MAF and
%the two approaches to flow-do ~wn can be augmented with these domain
%specific properties.
%
%
%http://sunset.usc.edu/classes/cs578{\_}2005/February8.pdf
%
%
%Un requisitos de un LDA es la composición, i.e., debe describir el
%sistema como una composición de partes.
%
%Configuración \textit{Debe describir la arquitectura independientemente de los componentes}
%Abstracción \textit{Debe describir los roles abstractos que juegan los componentes}??
%
%Reutilización \textit{Debe permitir reutilizar componentes, conectores, y arquitecturas}??
%
%Heterogeneidad \textit{Debe permitir combinar descripciones heterogéneas}??
%
%Análisis \textit{Debe permitir diversas formas de análisis de la arquitectura}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Notaciones de diseño}
\label{diseno:notaciones}

Existen multitud de notaciones de diseño utilizadas para describe los multiples artefactos necesarios para describir la arquitectura del sistema y su diseño. Muchas técnicas son exclusivas de los métodos estructurados, otras de los métodos orientados a objetos, pero es bastante habitual que un mismo proyecto utilize distintas notaciones para distintas partes del proyecto. Por ejemplo, hoy día lo más normal es basarse en la orientación a objetos y utilizar UML como lenguaje de modelado, pero parte de ese mismo proyecto podría modelar la base de data mediante Entidad/Relación, diagramas de flujo o tablas de decisión para describir algoritmos concreto, y \emph{storyboards} para describir interfaces de usuario. En la siguiente sección~\ref{diseno:metodos} se describen las notaciones más relevantes junto con los métodos de diseño en sistemas estructurados, orientados a objetos o de bases de datos.

%Estas notaciones se pueden agrupar en dos grandes grupos, estructurales y de comportamiento. Entre las estructurales tenemos:
%
%Lenguajes arquitectónicos
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Descripciones estructurales}
%\label{diseno:notaciones:estructurales}
%
%Entre las descripciones estructurales podríamos considerar
%
%\subsubsection{Lenguajes arquitectónicos}
%
%Architecture description languages (ADLs): textual,
%often formal, languages used to describe a software
%architecture in terms of components and connectors
%
%

%Class and object diagrams: used to represent a set of
%classes (and objects) and their interrelationships
%

%Component diagrams: used to represent a set of
%components (“physical and replaceable part[s] of a
%system that [conform] to and [provide] the realization
%of a set of interfaces” [Boo99]) and their
%interrelationships [Boo99:c12,c31]
%

%.. Class responsibility collaborator cards (CRCs): used
%to denote the names of components (class), their
%responsibilities, and their collaborating components’
%names [Boo99:c4; Bus96]
%
%.. Deployment diagrams: used to represent a set of
%(physical) nodes and their interrelationships, and, thus,
%to model the physical aspects of a system [Boo99:c30]
%
%.. Entity-relationship diagrams (ERDs): used to represent
%conceptual models of data stored in information
%systems [Bud04:c6; Dor02:v1c5; Mar02:DR]
%
%.. Interface description languages (IDLs): programminglike
%languages used to define the interfaces (names and
%types of exported operations) of software components
%[Bas98:c8; Boo99:c11]
%

%.. Jackson structure diagrams: used to describe the data
%structures in terms of sequence, selection, and iteration
%[Bud04:c6; Mar02:DR]
%
%.. Structure charts: used to describe the calling structure
%of programs (which module calls, and is called by,
%which other module) [Bud04:c6; Jal97:c5; Mar02:DR;
%Pre04:c10]
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Descripciones de comportamiento}
%
%Activity diagrams: used to show the control flow from
%activity (“ongoing non-atomic execution within a state
%machine”) to activity [Boo99:c19]
%
%.. Collaboration diagrams: used to show the interactions
%that occur among a group of objects, where the
%emphasis is on the objects, their links, and the
%messages they exchange on these links [Boo99:c18]
%
%.. Data flow diagrams (DFDs): used to show data flow
%among a set of processes [Bud04:c6; Mar02:DR;
%Pre04:c8]
%
%.. Decision tables and diagrams: used to represent
%complex combinations of conditions and actions
%[Pre04:c11]
%
%.. Flowcharts and structured flowcharts: used to
%represent the flow of control and the associated actions
%to be performed [Fre83:VII; Mar02:DR; Pre04:c11]
%
%Decision tables and diagrams: used to represent
%complex combinations of conditions and actions
%
%Flowcharts and structured flowcharts: used to
%represent the flow of control and the associated actions
%to be performed
%
%Sequence diagrams: used to show the interactions
%among a group of objects, with emphasis on the timeordering
%of messages [Boo99:c18]
%
%.. State transition and statechart diagrams: used to show
%the control flow from state to state in a state machine
%[Boo99:c24; Bud04:c6; Mar02:DR; Jal97:c7]
%
%.. Formal specification languages: textual languages that
%use basic notions from mathematics (for example,
%logic, set, sequence) to rigorously and abstractly define
%software component interfaces and behavior, often in
%terms of pre- and post-conditions [Bud04:c18;
%Dor02:v1c6s5; Mey97:c11]
%
%.. Pseudocode and program design languages (PDLs):
%structured-programming-like languages used to
%describe, generally at the detailed design stage, the
%behavior of a procedure or method [Bud04:c6;
%Fre83:VII; Jal97:c7; Pre04:c8, c11]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Métodos de diseño}
\label{diseno:metodos}

Con la aparición de lenguajes de programación era posible
desarrollar una gran cantidad de código, pero de manera poco
estructurada y difícil de mantener, lo cual se llamo "código
spaghetti". Sobre finales de los años 1960, Dijkstra~\cite{Dijkstra:1970;Dahl:Dijkstra:Hoare:1972} demostró
todo programa puede escribirse utilizando únicamente (i) bloques secuenciales de instrucciones
(ii) instrucciones condicionales y (iii) bucles. Con los lenguajes estructurados, aparecieron los métodos de diseño estructurados.

Después, con el paradigma de la orientación a objetos, iniciado por dos físicos noruegos Ole-Johan Dahl (1931-2002) y Kristen Nygaard (1926-2002) con el lenguaje SIMULA, se han ido creado los métodos de diseño orientados a objetos, siendo hoy día son los más frecuentemente utilizados. En esta sección se proporciona una visión de cómo los métodos de diseño han
ido evolucionando a medida que han ido apareciendo nuevos paradigmas
y lenguajes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Métodos estructurados}
\label{diseno}

Como se ha comentado anteriormente, con la aparición de la programación estructurada, surgen los métodos estructurados como una forma sistemática de desarrollo de software. Las \textit{metodos estructurados} se basan en una aproximación descendente (\emph{top-down}) que aboga
por descomponer en niveles funcionales con sus entradas y salidas,
desde una visión global hasta el nivel de detalle necesario para su
implementación.

\begin{figure}[htbp]
\centerline{\includegraphics[]{./5Diseno/figs/evolucionEstructurados.eps}}%[width=.7\textwidth]
%width=2.35in,height=2.02in
\caption{Vistas de los métodos
estructurados (adaptado de Pressman)} \label{fig:vistasEstructurado}
\end{figure}


%\begin{tabular}{ll}
%  \hline
%  Método & Comentario\\
%  \hline\hline
%  DeMarco & 1979 \cite{DeMarco:1979} \\
%  Jackson & \\
%  Gene y Sarson & \cite{Gane:Sarson:1977} \\
%  Yourdon y Constantine &  \cite{Yourdon:1993;Yourdon:1989}\\
%  SSADM & 1980 Promovido por el gobierno británico\\
%  MERISE & 1970 Promovido por del gobierno frances \\
%  Métrica & \\
%  \hline
%\end{tabular}



La característica más importante de los métodos estructurados es la
descomposición funcional del sistema de información, el modelado de
los datos y la representación del flujo de información, que
conforman las distintas vistas del sistema (figura~\ref{fig:vistasEstructurado} adaptada de~\cite{pressman:01})

\begin{figure}[htbp]
\centerline{\includegraphics[width=2.2in]{./5Diseno/figs/estructurado.eps}}%[width=.7\textwidth]
%width=2.35in,height=2.02in
\caption{Vistas de los métodos
estructurados (adaptado de Pressman)} \label{fig:vistasEstructurado}
\end{figure}


En la fase de análisis y especificación de los requisitos mediante
métodos estructurados, las técnicas más utilizadas son los
diccionarios de datos, los Diagramas de Flujo de Datos (DFD), los
diagramas de entidad-relación (E/R) y los diagramas de transición de
estados.


Las relaciones entre los datos se suelen primero modelar mediante el modelo
\textbf{Entidad-Relación} (ver sección \ref{}). Debido a su importancia, y a que es el principal diagrama de muchas aplicaciones orientadas a datos, se trata en más
detalle en la siguiente sección.


Los \textbf{diagramas de flujo de datos} (DFDs) se asemejan a un grafo que representa los flujos de datos y las transformaciones que se aplican sobre ellos. Los nodos
representan procesos y los vértices las entradas y salidas a los
mismos. Las entradas y salidas pueden ser externas al sistema y
puede haber almacenes de datos entre los nodos. Los DFDs pueden
descomponerse en otros sub-diagramas hasta llegar a un nivel de
granularidad apropiado para el diseño siguiendo una aproximación
descendente. La figura~\ref{fig:ejemploDFD} muestra un ejemplo de descomposición de
DFDs en posibles niveles. El nivel superior se denomina \emph{nivel de contexto}, a los procesos que no se descomponen se les denomina \emph{procesos primitivos}. Finalmente, para representar los DFDs existen diferentes notaciones aunque todas muy similares, los componentes de los DFDs son: (i)los \emph{procesos} que describen las funcionalidades del sistema, (ii) \emph{almacenes} que representan los datos utilizados por el sistema, (iii) \emph{entidades externas} que representan la la fuente y/o destino de la información del sistema y (iv) los \emph{flujos de datos} representando el movimiento de datos entre las funciones.


\begin{figure}%[htbp]
\centerline{\includegraphics[width=.9\textwidth]{./5Diseno/figs/DFDs.eps}}%width=2.81in,height=2.91in
\caption{Niveles en los diagramas de flujo de datos}
\label{fig:ejemploDFD}
\end{figure}


Los \textbf{diccionarios de datos} (DD) contienen los datos utilizados
en el sistema, de tal forma que todos los participantes del proyecto
tengan la misma visión de la información manejada por el sistema. La figura \ref{fig:diseno:diccionarioDatos} muestra un ejemplo de diccionario de datos. Los DD representan la información de los flujos de datos y los almacenes del sistema.


\begin{figure}%[htbp]
\begin{center}
\begin{tabular}
{|p{11.5cm}|}
\hline
\texttt{CLIENTE = @DNI + NOM\_CLIENTE + DIRECCION + \{NUM\_TLF\}} \par \texttt{DIRECCION = [CALLE + NUM + PROV $\vert $ APT{\_}CORREOS ]} \par \textsf{\ldots } \\
\hline
\end{tabular}
\begin{tabular}{|p{3.5cm}p{7.6cm}|}
  \hline
  \textbf{Notación:} & \\
  \texttt{@} & Identificador \\
  \texttt{= \ldots + \ldots} & Composición\\
  \texttt{\{ \}} & Iteración\\
  \texttt{$[ \ldots | \ldots ]$} & Selección\\
  \hline
\end{tabular}
\end{center}
\caption{Ejemplo de diccionario de datos} \label{fig:diseno:diccionarioDatos}
\end{figure}


Los \textbf{diagramas de estructura} (\emph{Structure Chart}) son utilizados para representar gráficamente la estructura modular en un sistema estructurado, es decir, la jerarquía de módulos junto con las llamadas entre los módulos (control). Tal y como muestra la figura~\ref{fig:diseno:diagramaEstructura}, los diagramas de estructura se obtienen a partir de los DFDs, transformandolos en árboles que descomponen el sistema en sus funcionalidades básicas.Además de la descomposición del sistema en sus módulos, los diagramas de estructura muestran información sobre la secuencia de ejecución (secuencial, repetitiva y alternativa), control y datos enviados o recibidos.

\begin{figure}
\begin{center}
    \epsfig{file=./5Diseno/figs/diagramasEstructura.eps, width=13.5cm}%,
\end{center}
\caption{Diagramas de estructura} \label{fig:diseno:diagramaEstructura}
\end{figure}

Finalmente, la descripción de módulos individuales puede hacerse mediante numerosas técnicas, que incluyen: (i) las \textit{tablas de transiciones} (también llamadas tablas de decisión), (ii) árboles de decisión, (iii) los \textit{diagramas de estados} y (iv) \emph{pseudocódigo}. La figura~\ref{fig:diseno:tablaTransicion} muestra un ejemplo de
tabla de decisión, donde en forma matricial se definen las reglas con las acciones a realizar dadas ciertas condiciones.

Los árboles de decisión

Los \textit{diagramas de estados} fueron originalmente desarrollados por Harel~\citeyear{Harel:1987} para representar autómatas finitos, aunque
son ampliamente utilizados en otras áreas como compiladores, sistemas de control, etc. También fueron adoptados por UML, como se verá en la sección \ref{}.





\begin{figure}%[htbp]
\begin{center}
\begin{tabular}
{|l|l|l|l|}
\hline
& \multicolumn{3}{|l|}{\emph{Regla}}  \\
\hline
& 1& 2& 3 \\
\hline
\multicolumn{4}{|l|}{\emph{Condiciones}}  \\
\hline
Edad $>$ 60& Sí & No& Sí \\
\hline
Estadio I & No & Sí & No \\
\hline
Estadio II& No& No& Sí  \\
\hline
\multicolumn{4}{|l|}{\emph{Acción}}  \\
\hline
Tratamiento A& X& X& - \\
\hline
Tratamiento B& -& X& X \\
\hline
Tratamiento C& -& -& X \\
\hline
\end{tabular}
\end{center}
\caption{Ejemplo de tabla de transición}
\label{fig:diseno:tablaTransicion}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{tabular}{|p{5in}|}
\hline
Otros Métodos de diseño clásicos \\
\hline
Dentro de los métodos clásicos, también existen otras técnicas que
por su importancia que tuvieron en el pasado se enumeran y describen
brevemente:\\
\begin{description}
  \item[Lenguajes de diseño de programas (PDLs --
  \textit{Program design languages})] Expresan la lógica de los
  programas de manera similar al pseudocódigo y sus interfaces.
  Surgieron como sustitutos de los diagramas de flujo y tenían la
  ventaja de que podían ser validados mediante herramientas \cite{caine:1975,Wasserman:1979} (Caine,  1975) (Wasserman, 1979)

  \item[Métodos estructurados orientados a datos] Muchos de los
  programas en lenguajes como COBOL, estaban orientados a la
  transformación de datos (registros) de entrada en otros de salida,
  siendo los datos en núcleo del sistema. Métodos representativos
  de este grupo son \citeyear{Warnier:1974}  -Warnier (1974) y Jackson \citeyear{Jackson:1975}. El método de
  Jackson (Jackson Development Method -- JDM) fue particularmente
  relevante al ser la base de otros métodos posteriores. Inicialmente
  basado en el teorema demostrado por Dijikstra, propuso 3 estructuras básicas para modelar
  programas : (i) secuencialización; (ii)
  iteración y (iii) selección. Después el método fue extendido a otras
  fases del ciclo de vida y automatización en la generación de código.

%  (ver Figura~\ref{fig:JDM})
%  \begin{figure}%[htbp]
%  \centerline{\includegraphics[width=5.22in,height=3.00in]{./5Diseno/figs/d15.eps}}
%  \caption{Diagrama de Jackson} \label{fig:JDM}
%  \end{figure}

  \item[JAD (\emph{Joint Application Development})] Esta técnica (descrita
  en Capitulo~\ref{requisitos} de requisitos) fue muy popular por lo que se
  extendió a la fase de diseño, sobre como abordar las reuniones en la fase
  de diseño en una misma localización o incluso reuniones virtuales.

\end{description}
\\

\hline
\end{tabular}


%Although based on structured programming, there are significant differences
%between these popular software design methods. Structured Design (SD)
%partitions a system into a hierarchical structure of loosely coupled modules
%within which exists tightly coupled code. Using data flow diagrams (DFDs), a
%data dictionary, structured English, and decision tables and trees,
%Structured Analysis (SA) builds a structured system specification
%(establishing new standards for documenting the analysis phase of system
%development). The output of a SA phase serves as input to the structured
%design (SD) phase where a concept known as source/transform/sink (STS)
%decomposition is applied to the DFDs to identify program modules. A source
%identifies the bounds of the input data stream, a sink encapsulates the
%output data stream, and the transform identifies the process of mapping the
%input to the output. Structured design is primarily a method for
%architectural design and its greatest strength lies in the early
%specification of subsystem interfaces. Its weaknesses lie in its narrow
%focus. It provides little direct help with specification and detailed design
%although the development of structured analysis has satisfied
%thespecificaion side.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Métodos orientados a datos}
\label{subsec:metodoDatos}





%\subsubsection{Modelo Entidad/Relación}


%El modelo Entidad-Relación (E/R) fue propuesto por Chen en 1976 con
%la finalidad de describir las entidades (abstracciones) existentes
%en el dominio del problema, así como las relaciones que se
%establecen entre las mismas desde el punto de vista estático. El
%modelo E/R utiliza tres elementos básicos: entidades, relaciones y
%atributos:
%
%\begin{itemize}
%  \item Entidades, representan los elementos del dominio del problema, i.e.,
%abstracciones. Las entidades regulares son las que si poseen un
%identificador único.
%
%  \item Relaciones. Son asociaciones entre entidades. Las relaciones
%  se denotan por rombos que conectan a las entidades participantes
%  mediante líneas.
%
%  \item Atributos. Son cada una de las propiedades de las entidades o relaciones. Se
%representan habitualmente mediante elipses unidos la entidad o
%relación al que pertenecen. Las distintas entidades de un tipo se
%distinguen mediante un atributo identificador único (clave) de la
%entidad.
%
%\end{itemize}
%
%
%\begin{figure}[htbp]
%\centerline{\includegraphics[width=5.26in,height=3.30in]{./5Diseno/figs/d16.eps}}
%\caption{. Diagrama de paquetes} \label{fig16}
%\end{figure}
%
%
%El modelo E/R es un diagrama ``\textit{lógico}'', donde existen
%distintos tipos de entidades y atributos: entidades regulares y
%débiles. Una entidad es débil cuando es no es posible identificar
%una clave única, sino que es necesario poner dichas entidades en
%relación con otras para lograr una identificación. Los atributos
%pueden ser univaluados o multivaluados, y además pueden ser simples
%o compuestos. Además, el modelo ER distingue dos tipos de
%restricciones:
%
%\begin{itemize}
%  \item La restricción de cardinalidad especifica el número máximo de
%veces que una entidad puede participar en una relación, y distingue
%tres tipos de cardinalidades: 1:1, 1:N (uno a muchos) y M:N (muchos
%a muchos).
%  \item La restricción de dependencia se da entre una entidad débil y la
%entidad regular de la que depende. Esta restricción significa que no
%puede existir una entidad débil si no existe la entidad regular que
%la identifica.
%\end{itemize}
%
%
%Por tanto, para poder representar su estructura física generalmente
%hay un proceso de normalización, es decir, un proceso de
%organización de los datos en conjuntos distintos y únicos al ser
%guardados en las tablas de la base de datos de forma que: (i) se
%reduzcan o eliminen el almacenamiento de datos duplicados en
%distintas entidades; y (ii) organicen los datos en una estructura
%lógica y eficaz. Los pasos del proceso de normalización están
%definidos en las llamadas \textit{formas normales}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%\subsubsection{Diagramas de estructura de datos}

Un gran porcentaje de aplicaciones y prácticamente las aplicaciones de gestión
gestión manejan una serie de datos bien en ficheros o bien mediante
bases de datos. El modelo Entidad/Relación (E/R) estudiado en~\ref{requisitos:notaciones:entidad}, no
sólo es una de las formas más comunes de expresar los resultados
del análisis de un sistema en etapas tempranas del desarrollo, sino
que además suele ser el punto de partida para el diseño de las bases de datos en los sistemas.

Una vez obtenido diagrama E/R (modelo conceptual), este se normaliza para obtener el diseño lógico de la base de datos (modelo físico). Ello se consigue aplicando un conjunto de
reglas a cada uno de los elementos del modelo conceptual para que,
conservando la semántica, se transforme en un elemento del modelo lógico. En muchos casos la transformación es directa porque el concepto es el mismo (por ejemplo, las entidades
pasan a ser tablas en la base de datos), pero otras veces no existe
esta correspondencia, por lo que es necesario realizar un proceso de
transformación. Por ejemplo, la figura~\ref{fig:diseno:ejemploBasesDatos} muestra simplificadamente la transformación desde un modelo conceptual en E/R a tablas en una base de datos; por ejemplo, en este caso la relación\emph{participa}  $N:M$ -- muchos a muchos --  se transforma en una tabla intermedia, conservando así la semántica de la relación.

\begin{figure}%[htbp]
\centerline{\includegraphics[width=5.24in,height=3.52in]{./5Diseno/figs/ejemploBasesDatos.eps}}
\caption{Transición desde el modelo E/R al diseño físico de bases de datos}
\label{fig:diseno:ejemploBasesDatos}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Diseño orientados a objetos}
\label{subsubsec:mylabel2}

El paradigma de la orientación a objetos (OO) se remonta a 1967, año
en que  dos físicos noruegos Ole-Johan Dahl (1931-2002) y Kristen
Nygaard (1926-2002) desarrollaron los conceptos básicos de este tipo
de programación en un lenguaje llamado SIMULA. Entre los lenguajes
influenciados por SIMULA se encuentran Smalltalk, C++,
Eiffel, Java y C\#. Hoy día es el paradigma de programación más utilizado ya los lenguajes que cumplen las propiedades fundamentales de la orientados a objetos (ver tabla adjunta) permiten mejorar la calidad del software producido.

\begin{tabular}{|p{5in}|}
\hline
Propiedades de la orientación a objetos \\
\hline
\begin{description}
  \item[Abstracción] Se reduce la
complejidad del dominio abstrayendo hasta el nivel adecuado. En la
orientación a objetos la abstracción se representa mediante el
concepto de clase, que representa un conjunto de objetos concretos,
llamados instancias con sus propiedades y operaciones. Por ejemplo,
la clase \emph{Persona} se puede abstraer con los atributos como \emph{nombre},
\emph{fecha de nacimiento}, etc. y métodos necesarios para el sistema que
se quiere modelar.


  \item[Herencia] Esta propiedad permite definir una clase a partir de
otra u otras clases tal que la subclase tenga hereda las
características de la(s) superclase(s), más las características propias
de la subclase. Siguiendo con el ejemplo de la clase \emph{Persona} anterior, pueden
extender con las subclases \emph{Estudiante} y \emph{Profesor}, que heredan las
propiedades y métodos de la clase \emph{Persona} y añaden otros atributos y
métodos específicos.

  \item[Encapsulamiento] Los datos y operaciones de una clase están
agrupados tal que los clientes de una clase sólo necesitan conocer
la interfaz pública de la misma, es decir, los prototipos de las operaciones
pero no cómo están implementadas.
%Esta propiedad facilita que otras
%características no especificas de la orientación a objetos como son
%la reutilización y la ocultación de información.

%\begin{figure}[htbp]
%\centerline{\includegraphics[width=2.35in,height=2.26in]{./5Diseno/figs/d18.eps}}
%\caption{(a) Encapsulación de las propiedades (b) con metodos
%privados} \label{fig18}
%\end{figure}

  \item[Polimorfismo] Es la propiedad por la que un mismo nombre de método
esta asociado a distintos comportamientos. Los lenguajes orientados
a objetos proporcionan polimorfismo estático o dinámico. El
polimorfismo estático se consigue mediante plantillas, genéricos o
sobrecarga de operadores donde operaciones con el mismo nombre
pueden realizarse sobre distintos tipos de parámetros, por ejemplo,
sumas de enteros o reales, etc. El polimorfismo dinámico, en tiempo
de ejecución, llamado asignación
tardía o asignación dinámica (\textit{dynamic binding}) que resuelve
el método a llamar en el momento de la ejecución basándose el tipo
de la referencia. Por ejemplo, cuando la superclase Persona hace
referencia a un objeto de la clase Estudiante, una llamada al método
getCreditos de la devuelve el número de créditos de los que se ha
matriculado un estudiante; por otro lado, si hace referencia a un
profesor, devolvería el número de créditos de las asignaturas que
imparte.
\end{description}
\\
\hline
\end{tabular}

Con los lenguajes orientados a objetos, surgieron numerosos métodos de diseño orientados a objetos, con distintas notaciones y herramientas, dando lugar a lo que se conoció como la guerra de las metodologías. Entre las metodologías, destacaron Booch, OMT (\emph{Object Modeling Technique}) y OOSE/Objectory cuyos autores (G. Booch, J. Rumbaugh e I. Jacobson) se unieron dando lugar al lenguaje unificado de modelado (UML -- \emph{Unified Modeling Language}) y el \emph{Proceso Unificado} (ver sección \ref{modelos:introduccion:procesos} y cuadros asociados).

UML ha aglutinado las más importantes notaciones de distintas metodologías orientadas a objetos convirtiéndose en un estándar "de facto" y referencia para el diseño orientado a obje. Además, como afirman sus autores, el lenguaje unificado de modelado (UML, \textit{Unified Modelling Language}) es un lenguaje para visualizar,
especificar, construir y documentar sistemas en general pero
particularmente adaptado a sistemas software construidos mediante el
paradigma de la orientación a objetos. Lo mismo ha pasado con el Proceso Unificado y sus 4+1 vistas, que se han convertido en referencia del diseño orientado a objetos (ver cuadro \ref{}). Usando UML, un \textbf{modelo} captura una vista de un sistema abstrayendo y
describiéndolo un apropiado nivel de detalle. Los modelos a su vez se representan
mediante \textbf{diagramas}, que son es una representación
gráfica de un conjunto de elementos de modelado y sus relaciones.
%
%\begin{tabular}{|p{5in}|}\hline
%Definición\\\hline Un \textbf{diagrama} es una representación
%gráfica de un conjunto de elementos de modelado y sus relaciones
%que se asemejan a un grafo cuyos vértices o nodos son los elementos
%de modelado y los arcos que serían las relaciones entre los
%elementos.
%\\
%\hline
%\end{tabular}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{tabular}{|p{5in}|}
\hline
Las 4+1 vistas de Kruntchen~\citeyear{Kruchten:1995}\\
\hline
En el proceso unificado y al igual que en OpenUP (ver sección \ref{procesos:}), la arquitectura de un sistema se describe mediante 4 vistas complementarias más la vista de casos de uso complementado la información de las otras vistas:
% la arquitectura se documenta con las denominadas 4+1 vistas representadas con distintos modelos de UML.
%Mientas que las vistas de diseño y de proceso muestran los aspectos
%lógicos, las vistas de implementación y despliegue tratan los
%aspectos físicos, describiendo como el sistema se instala y se
%ejecuta en una red de ordenadores. A continuación se detallan las
%distintas vistas:

\begin{itemize}
  \item La \emph{vista de diseño} muestra como el sistema lleva a cabo los requisitos funcionales mediante la descomposición del sistema en sus elementos como clases y su comunicación entre estos.
%Para esta vista los
%diagramas más comunes que se suelen utilizar son los diagramas de
%clases, objetos para Mostar la parte estática y de interacción para
%la parte dinámica.

  \item La \emph{vista de implementación} describe la organización del sistema en módulos, componentes y paquetes cubriendo el ensamblado del sistema y la gestión de configuración, reuso y portabilidad.

%Ayuda en la parte
%de gestión al utilizarse para dividir el trabajo entre
%distintos equipos asignando requisitos a distintos paquetes. con la
%estimación de costes, planificación y monitorización del proyecto.
%El diagrama mas utilizado en esta vista es el diagrama de paquetes.

  \item La \textit{vista de procesos} describe los procesos y cómo estos se comunican, y aún menor nivel de detalle, los hilos de control en las clases (concurrencia y distribución de procesos).

%Describe por tanto la concurrencia y distribución de procesos, por
%lo que se tiene en cuenta requisitos no funcionales como la
%capacidad de rendimiento, escalabilidad, disponibilidad, tolerancia
%a fallos, etc. Un diagrama común de esta vista es el diagrama de
%actividades.

  \item La \textit{vista de despliegue} se utiliza para representar un conjunto de nodos físicos formando la topología hardware del sistema.

%El diagrama más común de
%esta vista es el diagramas de despliegue y diagramas de interacción,
%estados o actividades para aspectos dinámicos.

  \item La \textit{vista de los de casos de uso} describe los requisitos funcionales del sistema mediante casos de uso, que son utilizados para complementar las otras vistas y en todo el ciclo de vida (por ejemplo, para crear los casos de prueba).

%Sirve de base para
%complementar el resto de las vistas y especifica las fuerzas que
%configuran la arquitectura del sistema.
%
%El diagrama de casos de uso
%es utilizado en las distintas vistas y fases del ciclo de vida,
%desde los requisitos hasta el diseño de las pruebas del sistema. El
%diagrama de casos de uso generalmente se complementa con de
%diagramas de interacción y de actividades para modelar los escenarios de los requisitos.
\end{itemize}\\
\centerline{\includegraphics[width=3in]{./5Diseno/figs/4mas1vistas.eps}} \par  \\
\hline
\end{tabular}


En UML, los diagramas están clasificados en dos grupos:

\begin{itemize}
  \item \emph{Diagramas de estructura}, que reflejan la estructura física
(estática) del sistema por medio de sus clases, métodos, atributos,
interfaces, paquetes, etc. y sus relaciones.
  \item \emph{Diagramas de comportamiento}, que reflejan la forma en los distintos
elementos del sistema interactúan, colaboran, cambian de estado
durante la ejecución del sistema para proveer la funcionalidad
requerida.
\end{itemize}


%Quitar, dice Salva que esta figura no dice nada
%\begin{figure}[htbp]
%\centerline{\includegraphics[width=5.51in,height=3.08in]{./5Diseno/figs/d19.eps}}
%\caption{Clasificación de los diagramas en UML} \label{fig19}
%\end{figure}

En UML versión 2 existen 13 tipos de diagramas que formarían los
distintos modelos para cada una de las vistas. A continuación se proporciona una visión general de los diagramas más importantes y un resumen en la tabla~\ref{tab:diagramasUML}. Además a continuación se describen de manera muy general los diagramas más relevantes de UML sin entrar en detalle, ya que queda fuera del alcance de este libro el describir toda la notación exhaustivamente.


\begin{table}%[htbp]
\scriptsize
\caption{Diagramas de UML 2}
\begin{tabular} {l|l|p{270pt}|}
\hline
\multicolumn{3}{l}{\textbf{Diagramas de estructura}} \\
\cline{2-3}& Clases & Es el diagrama más importante que muestra un conjunto de clases, interfaces y colaboraciones con sus relaciones. \\
\cline{2-3} & \textbf{Objetos} & Muestra un conjunto de objetos y sus relaciones en un estado concreto. Generalmente, representan la instanciación de un diagrama de clases en un determinado punto en el tiempo. \\
\cline{2-3} & \textbf{Componentes}& Muestra los componentes que componen una aplicación con sus interrelaciones e interfaces publicas.  \\
\cline{2-3} & Estructura compuesta & Permite visualizar de manera gráfica las partes que definen la estructura interna de un clasificador, incluyendo sus puntos de interacción con otras partes del sistema. \\
\cline{2-3} & \textbf{Paquetes} & Muestran la organización en paquetes de los diferentes elementos que conforman el sistema, de forma que se puede especificar de manera visual el nombre de los espacios de nombres. \\
\cline{2-3} & \textbf{Despliegue} & Muestra la arquitectura física de un sistema, nodos en sus entornos de ejecución y como se conectan. \\
\hline
\multicolumn{3}{l}{\textbf{Diagramas dinámicos}} \\
\hline
& \textbf{Actividad }& Muestra los procesos de negocio y flujos de datos\\
\cline{2-3} & \textbf{Comunicación} & Muestra la organización structural de los objetos y el paso de mensajes entre ellos. \\
\cline{2-3} & \textbf{Interacción} & Variante del diagrama de actividades para mostrar el flujo de control de un sistema o proceso de negocio.
%Interaction Overview -- A variant of an activity diagram which overviews the control flow within a system or business process.~~ Each node/activity within the diagram can represent another interaction diagram.
\\
\cline{2-3} & \textbf{Secuencia} & Modela la secuencia lógica de mensajes entre participantes (generalmente clases) temporalmente.  \\
\cline{2-3} & \textbf{Máquina de estados} & Describe los distintos posibles estados de un objetos junto con sus transiciones (generalmente utilizado para representar el comportamiento de clases complejas.\\
%Describes the states an object or interaction may be in, as well as the transitions between states. Formerly referred to as a state diagram, state chart diagram, or a state-transition diagram.
\cline{2-3} & \textbf{Tiempos} & Muestra los cambios de estado o condición de objetos a eventos externos sobre el tiempo.
%Depicts the change in state or condition of a classifier instance or role over time. Typically used to show the change in state of an object over time in response to external events.
\\
\cline{2-3} & \textbf{Casos de Uso} & Muestra los casos de uso, actores y sus relaciones.  \\
\cline{2-3}%\hline
\end{tabular}
\label{tab:diagramasUML}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Diagrama de casos de uso}
Como se ha visto en capítulo \ref{requisitos:notaciones:casos}, los diagramas de Casos de Uso (UC) son una técnica para la captura y especificación de requisitos, principalmente requisitos
funcionales, que un sistema proporciona en un entorno. Aunque estrictamente hablando la técnica de los UC no pertenece al enfoque orientado a objetos, ha sido adoptada por UML y por ende, del diseño orientado a objetos.

Una vez especificados los requisitos las distintas vistas de un sistema (por ejemplo, las 4+1 vistas de Kruntchen) se pueden describir con el resto de diagramas de UML. Es importante resaltar que no es necesario utilizar todos los tipos de diagramas en los proyectos, al igual que generalmente no se especifica completamente los diagramas al 100\%, es decir, hay un balance entre completitud y eficiencia desde el punto de vista del diseñador/a.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsubsection{Clases, objetos y relaciones}
%\label{subsubsec:clases}
%
%Las \textit{clases} abstraen las características comunes a un
%conjunto de objetos, por ejemplo la clase \textsf{Persona} podría
%abstraerse con una serie de propiedades como nombre, fecha de
%nacimiento, etc. Los objetos son instancias concretas de las clases,
%por ejemplo `John Smith' sería un objeto de la clase
%\textsf{Persona}.
%
%
%Las clases se representan mediante un rectángulo dividido en 3
%secciones (ver Figura ?`?`?), la primera tiene el \textit{nombre} de
%la clase, la segunda sus \textit{atributos} (propiedades) y la
%tercera sección contiene las \textit{operaciones} (métodos) de la
%clase indicando los servicios que proporciona la clase. En realidad
%puede existir una cuarta sección indicando de forma textual la/s
%responsabilidad/es de la clase. UML tiene una serie de reglas
%sintácticas y semánticas para cómo llamar a los elementos,
%definiciones de alcance, visibilidad de lo elementos, cómo definir
%la integridad y cómo simular un modelo dinámico. Los nombres de las
%clases deberían ser sustantivos en singular y empezar por mayúscula
%(ver Figura ???).
%
%%\begin{center}
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=2.82in,height=3.04in]{./5Diseno/figs/d20.eps}}
%%\caption{. Diagrama de tiempos}
%%\label{fig20}
%%\end{figure}
%%\end{center}
%
%\begin{figure}%[htbp]
%\centerline{\includegraphics[width=3.86in,height=1.35in]{./5Diseno/figs/d21.eps}}
%\caption{Clase con atributos y métodos} \label{fig21}
%\end{figure}
%
%Las relaciones son conexiones entre elementos. En un sistema las
%entidades siempre necesitan colaboran entre ellas para realizar la
%funcionalidad requerida. Por ejemplo si necesitamos conocer en que
%empresa trabaja una persona, habrá una asociación entre las clases
%\texttt{Persona} y \texttt{Empresa}. En UML existen tres tipos de
%relaciones importantes denominadas: \textit{dependencia} que es una
%relación de uso; \textit{generalización}, que conectan clases por
%medio de la herencia (generalización especialización);
%\textit{asociación}, donde una clase tiene una relación estructural
%con otra clase, por ejemplo \texttt{Circulo} y \texttt{Punto}.
%
%\begin{figure}[htbp]
%\centerline{\includegraphics[width=1.99in,height=0.60in]{./5Diseno/figs/d22.eps}}
%\caption{Tipos de relaciones} \label{fig22}
%\end{figure}


%Técnicas para descubir objetos
%
%\begin{table}[htbp]
%\begin{tabular}
%{|p{426pt}|}
%\hline
%CRC Cards \\
%\hline
%One of the most valuable techniques in coming up with a good 00 design is to explore object interactions, because it focuses an behavior rather than data . CRC (Class-Responsibility-Collaboration) diagranis, invented by Ward Cunningham in the late 1980s, have stood the test of time as a highly effective wav to do this (Figure 4.6) . Although they aren't part of the UML, they are a very popular technique among skilled object designers . To use CRC cards, you and your colleagues gather around a table . Take various scenarios and act them out with the cards, picking them up in the air when they are active and moving them to suggest how they send messages to each other and pass them around . This technique is almost impossible to describe in a book et is casily demonstrated ; the best way to learn it is to have someone who has dope it show it to you . \par \centerline{\includegraphics[width=6.05in,height=3.54in]{./5Diseno/figs/d23.eps}} \par  \\
%\hline
%\end{tabular}
%\caption{. Las 4+ 1 vistas de Kruntchen}
%\label{tab5}
%\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Diagrama de clases}
El diagrama de clases es el modelo estático más
importante. Muestra las clases, interfaces
y sus relaciones. Las \textit{clases} abstraen las características comunes a un
conjunto de objetos, por ejemplo la clase \texttt{Persona} podría
abstraerse con una serie de propiedades como nombre, fecha de
nacimiento, etc. Los objetos son instancias concretas de las clases,
por ejemplo `John Smith' sería un objeto de la clase
\texttt{Persona}.  Las objetos o entidades siempre necesitan colaboran entre ellas para realizar la funcionalidad requerida, las relaciones como conexiones entre los elementos se denominan \emph{asociaciones}. Hay diferentes tres tipos de asociaciones: herencia, agregación y composición.

La figura \ref{fig:diseno:diagramaClases} muestra un ejemplo de diagrama de clases. Las clases se representan mediante un rectángulo dividido en 3
secciones, la primera tiene el \textit{nombre} de
la clase, la segunda sus \textit{atributos} (propiedades) y la
tercera las \textit{operaciones} (métodos) de la
clase indicando los servicios que proporciona la clase. A las conexiones entre las clases representan las asociaciones.

\begin{figure}%[htbp]
\centerline{\includegraphics[width=3in]{./5Diseno/figs/diagramaClases.eps}}%width=3.90in,height=2.40in
\caption{Diagrama de clases}
\label{fig:diseno:diagramaClases}
\end{figure}

A una instanciación de un diagrama de clases mostrando los objetos y sus relaciones en un instante concreto, i.e., un determinado punto en el tiempo, se le denomina \textbf{diagrama de objetos}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\paragraph{Diagrama de objetos}
%El diagrama de objetos muestra un conjunto de objetos y sus
%relaciones en un estado concreto. Generalmente, representan la
%instanciación de un diagrama de clases en un determinado punto en el
%tiempo o de un diagrama de interacción. La figura ?`?? muestra un
%ejemplo de diagrama de objetos.
%
%\begin{figure}[htbp]
%\centerline{\includegraphics[width=3.54in,height=0.94in]{./5Diseno/figs/d25.eps}}
%\caption{Diagrama de objetos} \label{fig25}
%\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Diagrama de componentes}

Estos diagramas muestran los elementos físicos del sistema tales como librerías, APIs, archivos, etc. y sus relaciones.

La figura~\ref{fig:diseno:diagramaComponentes} se muestra un ejemplo de diagrama de componentes. Un componente se pueden agrupar, por ejemplo, varias clases e interfaces representado cierta funcionalidad agrupada en una librería dinámica o un programa ejecutable. La asociación (mostrada mediante una flecha discontinua muestra la dependencia de un paquete sobre otro y el círculo representa una interfaz.

\begin{figure}%[htbp]
\centerline{\includegraphics[width=2in]{./5Diseno/figs/diagramaComponentes.eps}}
\caption{Diagrama de componentes}
\label{fig:diseno:diagramaComponentes}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\paragraph{Diagrama de estructura compuesta}
%\label{subsubsec:estructuraDeCompuesta}
%
%
%Permite visualizar de manera gráfica las partes que definen la
%estructura interna de un clasificador, incluyendo sus puntos de
%interacción con otras partes del sistema. Pueden ser usados para
%representar patrones.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Diagramas de interacción}
\label{subsubsec:interaccion}

Estos diagramas muestran como interactuan (mediante el paso de mensajes) los objetos o clases entre si y pueden ser de dos tipos:

\begin{itemize}
  \item \textbf{Diagramas de secuencia}. Resaltan el paso de mensajes en el
  tiempo, es decir, su ordenación temporal.

  \item \textbf{Diagramas de comunicación} (antes llamados diagramas de colaboración). Son equivalentes a los diagramas de secuencia, pero destacan la organización en la comunicación entre los objetos, es decir, como los mensajes unen los objetos en lugar del tiempo.
\end{itemize}

La figura~\ref{diseno:fig:diagramaSecuanciaComunicacion} muestra un ejemplo muy simplificado de diagrama de secuencia~(a) y su diagrama de comunicación equivalente~(b) resaltado el paso de mensajes en el tiempo y o la secuencia de mensajes respectivamente.

\begin{figure}%[htbp]
\centerline{\includegraphics[width=6in]{./5Diseno/figs/diagramaSecuenciaComunicacion.eps}}%width=3.95in,height=2.42in
\caption{Ejemplos de diagrama de secuencia y de comunicación}
\label{diseno:fig:diagramaSecuanciaComunicacion}
\end{figure}

%\begin{figure}%[htbp]
%\centerline{\includegraphics[width=2.95in,height=1.99in]{./5Diseno/figs/d28.eps}}
%\caption{Ejemplo de diagrama de comunicación} \label{fig28}
%\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Diagramas de estados}

Los diagramas de estados, originalmente creados por Harel~\citeyear{Harel:1987}, representan autómatas de estados finitos mostrando los estados por los cuales puede pasar un objeto, junto con los cambios que permiten pasar de un estado a otro. Son útiles para representar objetos complejos con multiples estados, por ejemplo controladores. La figura~\ref{fig:diagramaEstados} muestra un ejemplo de diagrama de estados donde los nodos representan estados de la clase y los arcos representan eventos que realizan la transición entre los estados; la barra debajo de los eventos indica acciones y el texto entre corchetes representa las condiciones o guardias para realizar la transición entre estados.

\begin{figure}%[htbp]
\centerline{\includegraphics[width=4in]{./5Diseno/figs/diagramaEstados.eps}}%,height=2.39in
\caption{Diagrama de estados}
\label{fig:diagramaEstados}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Diagrama de actividad}
\label{subsubsec:actividades}

Un diagrama de actividad muestra paso a paso la estructura de un
proceso o algoritmo en forma de flujo de control. Es
decir, muestra cómo y qué hacen las acciones, así como su secuencia,
pudiendo además mostrar actividades paralelas, tomas de decisión, etc.

Aunque de notación similar a los diagramas de estados, los nodos de los diagramas de actividad muestran actividades, mientras que en los diagramas de estados los nodos muestran estados "fijos". Además, no son específicos de la orientación a objetos ya que suelen utilizarse para especificar procesos de negocio y con notaciones para representar flujo de control y paralelismo. La figura ............


%La
%figura~\ref{fig:diagramaActividades} muestra un ejemplo de diagrama
%de actividad.
%
%\begin{figure}%[htbp]
%\centering
%\centerline{\includegraphics[width=3.16in,height=5.15in]{./5Diseno/figs/d30.eps}}
%\caption{Ejemplo de diagrama de actividades}
%\label{fig:diagramaActividades}
%\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Diagrama de paquetes}
\label{subsubsec:actividades}

Muestra la organización en paquetes de los diferentes elementos que
conforman el sistema, de forma que se puede especificar de manera
visual el nombre de los espacios de nombres. La
figura~\ref{fig:diagramaPaquetes} muestra un ejemplo de diagrama de
paquetes.

\begin{figure}%[htbp]
\centerline{\includegraphics[width=3.00in,height=2.06in]{./5Diseno/figs/d31.eps}}
\caption{Ejemplo de diagrama de paquetes}
\label{fig:diagramaPaquetes}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Diagrama de despliegue}
\label{subsubsec:despliege}

Muestran la arquitectura del hardware del sistema y la distribución
física de los componentes software en el hardware. La
figura~\ref{fig:diagramaDespliege} muestra un ejemplo de diagrama de
despliege.

\begin{figure}[htbp]
\centerline{\includegraphics[width=3.54in,height=1.81in]{./5Diseno/figs/d32.eps}}
\caption{Ejemplo de diagrama de despliege}
\label{fig:diagramaDespliege}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsubsection{Diagramas de estructura compuesta}
%\label{subsubsec:estructuraCompuesta}
%
%Permiten dividir complejos diagramas en otros más simples.
%
%\begin{figure}
%\centerline{\includegraphics[width=3.11in,height=3.33in]{./5Diseno/figs/d33.eps}}
%\label{fig33} \caption{Ejemplo de diagrama de estructura compuesta}
%\end{figure}
%
%Además, como parte de estructuras compuestas, UML define las
%\textit{colaboraciones}. La Figura muestra una colaboración (elipse
%discontinua) y dentro los roles que participan. Se han propuesto
%como una forma de mostrar patrones.
%
%
%\begin{figure}
%\begin{tabular}
%{|p{213pt}|p{213pt}|} \hline
%\centerline{\includegraphics[width=2.00in,height=1.64in]{./5Diseno/figs/d34.eps}}
%\par &
%\centerline{\includegraphics[width=2.008in,height=1.45in]{./5Diseno/figs/d35.eps}} \par  \\
%\hline
%\end{tabular}
%\caption{Ejemplo colaboración (a) roles dentro de colaboración y (b)
%roles fuera de la colaboración}
%\label{tab6}
%\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsubsection{Diagramas de interacción}
%\label{subsubsec:estructuraCompuesta}
%
%Unen los diagramas de actividad y con los diagramas de secuencia,
%mostrando por cada activad un diagrama de secuencia. La
%figura~\ref{fig:diagramaInteracion} muestra un ejemplo de diagrama
%de interacción.
%
%\begin{figure}%[htbp]
%\centerline{\includegraphics[width=4.58in,height=5.54in]{./5Diseno/figs/d36.eps}}
%\caption{Ejemplo de diagrama de interacción}
%\label{fig:diagramaInteracion}
%\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsubsection{Diagramas de tiempos}
%\label{subsubsec:estructuraCompuesta}
%
%Los diagramas de tiempo son una forma de diagrama de actividad,
%destacando el tiempo como restricciones en uno o varios objetos.
%
%\begin{figure}[htbp]
%\centerline{\includegraphics[width=3.22in,height=1.98in]{./5Diseno/figs/d37.eps}}
%\caption{Ejemplo de diagrama tiempos}
%\label{fig37}
%\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{tabular}{|p{5in}|}
\hline
El Lenguaje de Restricción de Objetos (OCL) \\
\hline
UML incorpora OCL (\emph{Object Constrain Language}) para extender la semántica de los
elementos de UML. Desde la concepción de UML, una de las criticas es
la ambigüedad de su semántica, por lo que UML versión 2 ha sido
extendido con OCL como lenguaje de primer orden, pensado para:\\
\begin{itemize}
  \item la especificación de \textit{invariantes} en las clases tipos o
interfaces
  \item describir \textit{precondiciones} y \textit{postcondiciones}
  en los métodos, guardas de los diagramas de estados, actividad, etc., como un lenguaje de navegación y reglas de formación.
  \item definir restricciones de operaciones.
\end{itemize}\\
Por ejemplo, la siguiente figura se muestra un diagrama de clases y una restricción de cardinalidad en OCL que no puede mostrarse utilizando UML, donde el número de pasajeros está limitado por el número de asientos disponibles en el autobús.\\
%\begin{figure}[htbp]
\centerline{\includegraphics[width=3in]{./5Diseno/figs/ejOCL.eps}}%width=3.22in,height=1.98in
%\label{fig:diseno:ejemploOCL} \caption{Ejemplo de diagrama tiempos}
%\end{figure}\\
Aparte del diseño, OCL se ha incorporado en herramientas capaces de traducir
restricciones OCL en aserciones del lenguaje de programación demostrando su utilidad en la verificación y pruebas de programas.
\\\hline
\end{tabular}


%\subsection{El Lenguaje de Restricción de Objetos (OCL) }
%\label{subsubsec:mylabel5}
%
%UML incorpora OCL (\emph{Object Constrain Language}) para extender la semántica de los
%elementos de UML. Desde la concepción de UML, una de las criticas es
%la ambigüedad de su semántica, por lo que UML versión 2 ha sido
%extendido con OCL como lenguaje de primer orden, pensado para:
%
%\begin{itemize}
%  \item la especificación de \textit{invariantes} en las clases tipos o
%interfaces
%  \item describir \textit{precondiciones} y \textit{postcondiciones}
%  en los métodos, guardas de los diagramas de estados, actividad, etc., como un lenguaje de navegación y reglas de formación.
%  \item definir restricciones de operaciones.
%\end{itemize}
%
%Por ejemplo la figura \ref{fig:diseno:ejemploOCL} muestra un diagrama de clases y una restricción de cardinalidad en OCL  que no puede mostrarse utilizando UML en donde el numero de pasajeros esta limitado por el número de asientos disponibles en el autobús.
%
%\begin{figure}[htbp]
%\centerline{\includegraphics[width=3in]{./5Diseno/figs/ejOCL.eps}}%width=3.22in,height=1.98in
%\label{fig:diseno:ejemploOCL} \caption{Ejemplo de diagrama tiempos}
%\end{figure}
%
%
%\begin{table}
%\begin{tabular}{|p{426pt}|}
%\hline
%    context Flight
%    inv: passengers->size() <= plane.numberOfSeats\\
%\hline
%\end{tabular}
%\label{tab8}
%\end{table}


%1) Para cada tipo de avión, el número de Personas no puede ser mayor
%al número de pasajeros
%
%2) Los viajes no pueden tener el mismo destino que el origen
%
%3) La cantidad de horas de vuelo de un avión debe ser menor a 1000
%
%4) Para aviones del tipo ``Delta'' de la serie ``A'', la cantidad de
%asientos para los pasajeros debe ser de 40
%
%5) Los pasajeros de los viajes deben ser mayores de 3 años y menores de
%95
%
%6) Un viaje debe tener más de 5 pasajeros
%
%7) La cantidad de tripulantes de un viaje debe ser menor o igual a la
%cantidad de pasajeros
%
%8) La cantidad de pasajeros de un viaje debe ser menor o igual a la
%capacidad de asientos del avión asignado al vuelo
%
%9) Un avión no puede tener mas de 500 viajes asignados en su vida
%útil si es del tipo ``Delta''
%
%10)Para los viajes que tengan asignados aviones con una cantidad de horas de
%vuelo superior a 500 hs, la edad de los tripulantes deben ser mayores a 50
%años


\begin{tabular}{|p{5in}|}
\hline
Principios del diseño orientado a objetos\\
\hline
Se han definido unos principios que permiten alcanzar los objetivos de una bajo
acoplamiento y una alta cohesión. Estos principios son:\\
\begin{itemize}
  \item \textbf{Principio abierto-cerrado}~\cite{Meyer99}. Un módulo debería ser a la vez abierto y cerrado: abierto para poder ser extendido y cerrado para ser modificado. Un módulo debería ser a la vez abierto y cerrado: abierto para poder ser extendido y
      cerrado para ser modificado. En otras palabras, un módulo debe poder extender su
      funcionalidad sin necesidad de modificar su código fuente. En la orientación a objetos, este principio se puede conseguir por medio de interfaces.
  \item \textbf{Principio de responsabilidad única}. Introducido DeMarco~\citeyear{DeMarco:1979} en el diseño estructurado, esta relacionado con el concepto de cohesión en el sentido de que una responsabilidad es una razón para el
      cambio y por tanto, cada clase debe tener una única responsabilidad.
      Como el objetivo es maximizar la cohesión, cuando los requisitos
      cambian, esos cambios se reflejan en cambios en las clases, i.e., las responsabilidades de las clases.
  \item \textbf{Principio de separación de la interfaz} Los clientes no deberían ser forzados a depender de interfaces que no utilizan. En otras palabras, es preferible tener muchas interfaces específicas que una sola interfaz de propósito general.
  \item \textbf{Principio de sustitución de Liskov} \cite{Liskov:1987} La herencia ha de garantizar que cualquier propiedad que sea cierta para los objetos de la clase padre, también lo son para los objetos de la clase hijo. Este principio expresado otras palabras afirma que las subclases deberían poder ser substituidas por sus superclases, es decir, un cliente de la clase base debe seguir funcionando adecuadamente si una clase derivada de esa clase base se le pasa a dicho cliente.
  \item \textbf{Ley de Demeter} Descrita por Lieberherr y Holland~\citeyear{Lieberherr:Holland:1989}, esta ley busca mejorar el acoplamiento entre clases y establece que cada unidad debería tener solamente un conocimiento limitado sobre otras unidades, sólo las relacionadas a la unidad. Informalmente también descrita como "Habla únicamente con tus amigos", o "No hables con extraños".
  \item \textbf{Principio de inversión de dependencias} Descrito por Martin~\citeyear{Martin:1996:DIP} establece que (1) los módulos de alto nivel no deben depender de los módulos de bajo nivel. Ambos deben depender de las abstracciones. (2) Las abstracciones no deben depender de los detalles. Los detalles deben depender de las abstracciones.

  \item \textbf{Principio de dependencias estables} Las dependencias entre paquetes en un diseño deberían ir encaminadas a la estabilidad de los paquetes. La estabilidad se mide por el número de dependencias de entrada y salida de un paquete. Cuantas más dependencias de entrada tiene un paquete, más estable necesita ser, ya que cualquier cambio afectará a todos los paquetes que dependen de él. Otra regla es importante es evitar ciclos en el diseño de una estructura de paquetes.
\end{itemize}
\\\hline
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsection{Principios del diseño orientado a objetos}
%\label{subsubsec:principios}
%
%Se han definido unos principios, que basados en las propiedades de
%la orientación a objetos como pueden ser la abstracción y el
%polimorfismo, ayudan a alcanzar los objetivos de una bajo
%acoplamiento y una alta cohesión. Estos principios son:
%
%\begin{itemize}
%  \item Principio abierto-cerrado
%  \item Principio de responsabilidad única
%  \item Principio de separación de la interfaz
%  \item Principio de sustitución de Liskov
%  \item Principio de inversión de dependencias
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsubsection{Principio abierto-cerrado}
%\label{subsubsec:principioOCP}
%
%\begin{tabular} {|p{380pt}|}
%\hline
%\textit{Principio abierto-cerrado (OCP)} \\
%\hline Un módulo debería ser a la vez abierto y cerrado: abierto para poder ser extendido y
%cerrado para ser modificado. \\
%\hline
%\end{tabular}
%
%En otras palabras, un módulo debe poder extender su funcionalidad
%sin necesidad de modificar su código fuente. En la orientación a
%objetos, este principio se puede conseguir por medio de las
%propiedades de abstracción y polimorfismo. Si se llaman dos clases
%concretas, por ejemplo, clases \texttt{Cliente} y \texttt{Servidor}
%no se cumple el principio abierto-cerrado ya si se desea que un
%objeto \texttt{Cliente} use un objeto \texttt{Servidor} diferente,
%se debe cambiar la clase \texttt{Cliente} para nombrar la nueva
%clase \texttt{Servidor}.  Para cumplir con el principio, se pueden
%crear clases abstractas que son fijas, y un conjunto de clases
%derivadas con los diferentes posibles comportamientos. De esta
%manera, una clase está cerrada para su modificación al depender de
%una abstracción que es fija, pero el comportamiento del módulo puede
%ser extendido mediante la creación de clases derivadas. Por ejemplo,
%se diseña una clase abstracta, \textsf{ServidorAbstracto} y la clase
%\texttt{Cliente} usa esa abstracción, los objetos de la clase
%\texttt{Cliente} utilizarán los objetos de las clases derivadas de
%la clase \texttt{ServidorAbstracto}. Los objetos de la clase
%\texttt{Cliente} pueden utilizar diferentes clases
%\texttt{Servidor}, ya que se derivan de la clase
%\texttt{ServidorAbstracto} y la clase \texttt{Cliente} no necesita
%ser modificada.
%
%\begin{figure}[htbp]
%\centerline{\includegraphics[width=3.64in,height=1.57in]{./5Diseno/figs/d39.eps}}
%\label{fig38} \caption{Separación de interfaces e implementaciones
%para cumplir el principio abierto-cerrado}
%\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Principio de responsabilidad única}
%\label{subsubsec:principioSRP}
%
%\begin{tabular}
%{|p{380pt}|}
%\hline
% \par Principio de responsabilidad única \\
%\hline
%Una clase sólo puede tener una razón para cambiar \\
%\hline
%\end{tabular}
%
%El principio de responsabilidad única (SRP, \textit{Single
%Responsibility Principle}) fue introducido por DeMarco y Pages-Jones
%(1979) pero también esta ligado a la definición de cohesión de
%Martin (2000?) en el que una responsabilidad es una razón para el
%cambio y por tanto cada clase debe tener una única responsabilidad.
%Como el objetivo es maximizar la cohesión, cuando los requisitos
%cambian, esos cambios se reflejan en cambios en las clases, i.e.,
%las responsabilidades de las clases. Cuando una clase tiene
%múltiples responsabilidades, también existen múltiples razones para
%cambio de una clase. Cumpliendo este principio, se evita que los cambios en una clase
%(cambios en una responsabilidad) provoquen fallos en otras partes de
%la clase (otras responsabilidades). Además, cuando una clase necesita los servicios de otra clase no necesita acarrear los servicios que no necesita generalizando el
%principio de segregación de la interfaz.

%PONER EJEMPLO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Principio de substitución de Liskov}
%\label{subsubsec:principioLiskov}
%
%
%\begin{tabular}{|p{380pt}|}
%\hline
%El Principio de Substitución de Liskov  \\
%\hline
%La herencia ha de garantizar que cualquier propiedad
%que sea cierta para los objetos supertipo también lo
%sea para los objetos subtipo.\\
%\hline
%\end{tabular}
%
%
%Este principio expresado otras palabras afirma que las subclases
%deberían poder ser substituidas por sus superclases, es decir, un
%cliente de la clase base debe seguir funcionando adecuadamente si
%una clase derivada de esa clase base se le pasa a dicho cliente. Por
%ejemplo, si a un método se le pasa un argumento del tipo
%\texttt{Seguro}, debería ser legal pasarle una instancia de
%\textsf{\textbf{SeguroCoche} ya que deriva directa o indirectamente
%de \texttt{Seguro}}.
%
%Las violaciones del principio de Liskov son violaciones enmascaradas
%del principio abierto-cerrado.
%
%
%%
%%PONER EJEMPLO Ejemplo de Martin, la elipse y el circulo.
%%
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=0.95in,height=1.29in]{d40.eps}}
%%\label{fig40}
%%\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsubsection{Principio de Inversión de la Dependencia (DIP)}
%\label{subsubsec:principioDIP}
%
%\begin{table}[htbp]
%\begin{tabular}
%{|p{426pt}|}
%\hline
%%\begin{figure}[htbp]
%%\centerline{\includegraphics[width=1.29in,height=2.00in]{./5Diseno/figs/d41.eps}}
%%\label{fig41}
%%\end{figure}
% \par Principio de Inversión de la Dependencia (DIP)  \\
%\hline
%(1) Los módulos de alto nivel no deben depender de los módulos de bajo nivel. Ambos deben depender de las abstracciones. \par (2) Las abstracciones no deben depender de los detalles. Los detalles deben depender de las abstracciones. \\
%\hline
%\end{tabular}
%\label{tab13}
%\end{table}
%

%
%Indica la dirección que tienen que tomar todas las dependencias en
%un diseño orientado a objetos. En otras palabras, este principio
%indica que los niveles deben depender de interfaces o métodos y
%clases abstractas, en lugar de depender de métodos y clases
%concretas. El OCP establece el objetivo, el DIP establece el
%mecanismo.
%
%
%
%Por ejemplo, la clase \textsf{Copiar} que manda la información de un
%lector hacia un escritor, depende de las abstracciones
%\textsf{Lector} y \textsf{Escritor} independientes de los módulos de
%bajo nivel. Se pueden añadir nuevos tipos de lectores y escritores
%sin que la clase copiar dependa en absoluto de ellos. La motivación
%que subyace en el DIP es prevenir dependencias a módulos volátiles y
%normalmente, las implementaciones concretas cambian con más
%frecuencia que las cosas abstractas. El DIP está relacionado con la
%heurística de DOO: ``Diseñe interfaces, no implementaciones
%
%
%%
%%
%%\begin{table}[htbp]
%%\begin{tabular}
%%{|p{426pt}|}
%%\hline
%%%\begin{figure}[htbp]
%%%\centerline{\includegraphics[width=2.96in,height=2.41in]{./5Diseno/figs/d42.eps}}
%%%\label{fig42}
%%%\end{figure}
%%\end{tabular}
%%\label{tab14}
%%\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsubsection{Principio de Segregación de la Interfaz}
%\label{subsubsec:principioSegregacionInterface}
%
%\begin{tabular}{|l|}
%  \hline
%  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
%  Principio de Segregación de la Interfaz\\
%  \hline
%  Es mejor muchas interfaces de cliente específicas que una sola interfaz de
%propósito general.  \\
%  \hline
%\end{tabular}
%
%Los clientes no deben ser forzados a depender de interfaces que no
%utilizan. Cuando hay clases con interfaces con muchos métodos, los
%clientes de esas interfaces acarrean funcionalidad (parte del
%interface) que no necesitan y lo que es peor, si hay cambios en esa
%funcionalidad o interfaz, puede necesitar cambiarse el cliente. Este
%principio esta relacionado con el acoplamiento estructural, creando
%interfaces más pequeñas y cohesivas, en lugar de interfaces con un
%gran número de métodos no cohesionadas.
%
%\begin{figure}[htbp]
%\begin{tabular}
%{|p{158pt}|p{222pt}|} \hline
%\centerline{\includegraphics[width=2.13in,height=2.16in]{./5Diseno/figs/d43.eps}}
% &
%\centerline{\includegraphics[width=2.38in,height=1.85in]{./5Diseno/figs/d44.eps}} \par  \\
%\hline
%\end{tabular}
%\label{tab15} \caption{(a) Interfaz no cohesionada (b) la misma
%interfaz dividida en interfaces más cohesivas}
%\end{figure}
%


%
%Por ejemplo, cuando hay una clase con varios clientes, en lugar de cargar la
%clase con todos los métodos que los clientes necesitan, crear interfaces
%específicas para cada tipo de cliente y que la clase herede de todas
%ellas (herencia múltiple, pero a nivel de interfaz).
%
%
%Este principio, no recomienda que cada clase que utilice un servicio tenga
%una propia clase interfaz especial de la cual herede el servicio. Lo que
%indica es que los clientes han de categorizarse por tipo y crear una
%interfaz para cada tipo de cliente. Si dos o más tipos diferentes de
%cliente necesitan el mismo método, el método ha de ser añadido
%en todas las interfaces.
%
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsubsection{Ley de Demeter o el principio de mínimo conocimiento)}
%\label{subsubsec:principioDIP}
%
%\begin{table}[htbp]
%\begin{tabular}
%{|p{426pt}|}
%\hline
%Ley de Demeter o el principio de mínimo conocimiento. \\
%\hline
%Un objeto a solo debería invocar métodos de otros objetos, durante la ejecución de un método m, si se trata de: \par 1. el mismo objeto a. \par 2. un objeto que figura como parámetro actual en la llamada a m. \par 3. un objeto creado por a durante la ejecución de m. \par 4. un objeto referenciado por un miembro dato de a. \par A method M of an object O may only invoke the methods of the following kinds of objects: \par 1. O itself  \par 2. M's parameters \par 3. any objects created/instantiated within M \par 4. O's direct component objects \par  \\
%\hline
%\end{tabular}
%\label{tab16}
%\end{table}
%
%http://en.wikipedia.org/wiki/Law{\_}of{\_}Demeter
%
%Formulada por K. Lieberherr (2000???), an object A can request a service
%(call a method) of an object instance B, but object A cannot ``reach
%through'' object B to access yet another object to request its services.
%Doing so would mean that object A implicitly requires greater knowledge of
%object B's internal structure. Instead, B's class should be modified if
%necessary so that object A can simply make the request directly of object B,
%and then let object B propagate the request to any relevant subcomponents.
%If the law is followed, only object B knows its internal structure.
%
%In particular, an object should avoid invoking methods of a member object
%returned by another method.
%
%The advantage of following the Law of Demeter is that the resulting software
%tends to be more maintainable and adaptable. Since objects are less
%dependent on the internal structure of other objects, object containers can
%be changed without reworking their callers. Basili et al published
%experimental results in 1996 suggesting that the Law of Demeter was a valid
%way to reduce the probability of software faults.
%
%
%A disadvantage of the Law of Demeter programación más tediosa al
%tener que generar muchas veces objetos \textit{wrapper} to propagate method calls to the
%components. Furthermore, a class's interface can become bulky as it hosts
%methods for contained classes resulting in a class without a cohesive
%interface.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Principios de arquitectura de paquetes}
%\label{subsubsec:mylabel6}
%
%\begin{tabular}
%{|p{380pt}|} \hline
%The Stable Abstractions Principle. \\
%\hline
%The more stable packages tend to have a higher proportion of Interfaces and abstract classes \\
%\hline
%\end{tabular}
%Cuantas más dependencias de entrada tiene un paquete, más estable
%necesita ser, ya que cualquier cambio afectará a todos los paquetes
%que dependen de él.
%
%Otra regla es importante es evitar ciclos en el diseño de una
%estructura de paquetes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MDA %%%

\begin{tabular}{|p{5in}|}
\hline
Arquitectura dirigida por modelos (MDA)
\\\hline
La MDA (\textit{Model Driven Architecture}) es un \textit{framework} ideado para desarrollo mediante modelos. Basado en UML, el desarrollo se realiza en tres niveles:

\begin{itemize}
  \item Primero, se define un modelo con un alto grado de abstracción,
independiente de la tecnología sobre la que se va a desarrollar, lo
que se llama PIM (\textit{Platform Independent Model}).
  \item Segundo, el modelo PIM se transforma en modelos específicos de la
plataforma, llamados PSM (\textit{Platform Specific Model}).
  \item Finalmente, se transforman los PSM en código ejecutable.
\end{itemize}

La transformación entre los niveles de abstracción, de PIM a
PSM y de PSM a código, se realiza mediante herramientas,
automatizando el proceso de transformación. Por lo que el desarrollo
se limita al modelado de alto nivel mediante UML y estándares
relacionados como OCL. Aunque se empiezan a ver algunas herramientas que lo hacen realidad, el principal inconveniente es el esfuerzo necesario en especificar los modelos
en el nivel de detalle necesario que permita su "compilación" y la
dificultad de proponer modelos independientes y la transformación
entre modelos.\\
\hline
\end{tabular}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Otras técnicas relacionadas con el diseño}
\label{diseno:otrosConceptos}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Los patrones de diseño software}
\label{diseno:patrones}

Los patrones tienen su origen en el trabajo de C. Alexander en 1979
en un libro titulado \textit{The Timeless Way of Building}, en el
que se describen el lenguaje de patrones para que individuos o grupos
de individuos construyan sus propias viviendas sin necesidad de
arquitectos. C. Alexander afirma: ``\textit{cada patrón describe un
problema que ocurre infinidad de veces en nuestro entorno, así como
la solución al mismo, de tal modo que podemos utilizar esta solución
un millón de veces en el futuro sin tener que volver a pensarla otra
vez}''.
%Por tanto, una buena solución a un problema recurrente en un
%contexto se denomina patrón.
Dentro de la ingeniería del software, Cunningham y Beck propusieron algunos patrones de interface de usuario a finales de los años 1980, pero su popularidad surgió con la obra de Gamma \textit{et al.}~\citeyear{gamma:etAl:1995} "\emph{Design Patterns: Elements of Reusable Object-Oriented Software}''. A día de hoy, se han especificado multitud de patrones en diferentes dominios y niveles de abstracción, por lo que en la industria del
software los patrones se podrían clasificar acorde al ámbito que abarcan lo que se ha dado a llamar, \textit{lenguajes de patrones}, como por ejemplo:

\begin{itemize}
  \item Patrones de interfaces de usuario, interacción
hombre-computador. El más conocido es quizás el MVC (Modelo-Vista-Controlador).
  \item Patrones de diseño, a nivel de un conjunto de clases en el paradigma de
la orientación a objetos.
  \item Modismos (\textit{programming} \textit{idioms}), `trucos' a nivel de lenguajes de programación concretos (C++, Java, etc.). Por ejemplo a veces son simples reglas a la hora de escribir código como prefijos para identificar el tipo de variables.
  \item Patrones para la integración de sistemas (EAI - \textit{Enterprise Application Integration}), para la intercomunicación y coordinación de sistemas, por ejemplo para Java EE.
  \item Patrones a nivel de organización y flujos de trabajo, \textit{workflows}, para la
gestión de flujos de trabajo y procesos con sistemas empresariales, por ejemplo cómo organizar al personal y su forma de trabajar.

\end{itemize}

En particular, en este capítulo nos interesan los patrones de diseño muestran descripciones de soluciones a problemas a nivel de clases e interfaces, y las
interacciones entre ellas.

\begin{tabular}{|p{5in}|}
\hline
Definición \\
\hline
Un patrón de diseño es una solución a un problema recurrente de carácter general a nivel de clases, interfaces, objetos y cómo estos interacturán.
\\\hline
\end{tabular}\\

Para que una solución sea considerada un patrón se considera que
debe poseer ciertas características que lo validan. Una de ellas es
que debe haber comprobado su efectividad resolviendo problemas
similares anteriormente, lo que se ha dado en llamar "\emph{la regla de
3}" que dice que no se debería afirmar que algo es un patrón a menos
que se haya usado en 3 ocasiones independientes es decir, aplicable
a diferentes problemas de diseño en distintas circunstancias. Otra
es la comparación con otras posibles soluciones mostrando sus
debilidades, que no sólo hayan sido escritas por un único autor y
finalmente que hayan sido criticadas por la comunidad. Aunque existe la barrera de aprendizaje de los patrones, una vez introducidos en los entornos de desarrollo, los patrones de diseño proporcionan como las siguientes:

\begin{itemize}
  \item La reutilización de arquitecturas completas yendo un paso
más allá que con la reutilización de simplemente clases y
componentes. Lo patrones además representan conocimiento sobre
decisiones de diseño con lo que la reutilización es más efectiva.
  \item Formalizar un vocabulario común entre diseñadores.
  \item Facilitar el aprendizaje condensando conocimiento ya
  existente.
\end{itemize}

El libro de Gamma \emph{et al} \citeyear{Gamma:EtAl:1995} también conocido como patrones GoF
(Gang of Four, debido a sus 4 autores: Gamma, Helm, Johnson y Vlissides) describe 23 patrones concretos mediante una plantilla con los campos principales siendo su nombre, propósito, motivación, aplicabilidad, el desarrollo del patrón, usos y ejemplos. Además los patrones están clasificados en 3 categorías: (i) creacionales, (ii) estructurales y de (iii) comportamiento.

%Los \emph{patrones de creacionales} proporcionan ayuda a la hora de
%crear objetos, principalmente cuando esta creación requiere tomar
%decisiones. Esta toma de decisiones puede ser dinámica. Estos
%patrones ayudan a estructurar y encapsular estas decisiones. En
%algunas ocasiones existe más de un patrón que se puede aplicar a la
%misma situación. En otras ocasiones se pueden combinar múltiples
%patrones convenientemente. Un patrón de creación asociado a clases
%usa la herencia para variar la clase que se instancia, mientras que
%un patrón de creación asociado a objetos delegará la instanciación a
%otro objeto.

%descritos por medio de una plantilla con los siguientes campos:
%\begin{itemize}
%  \item \textit{Nombre del patrón y clasificación}, nombre por el cual es reconocido en la comunidad y su clasificación.
%  \item \emph{Otros nombres, }por los que se puede reconocer el patrón
%  \item \emph{Propósito}, pequeña descripción de lo que hace el patrón
%  \item \emph{Motivación}: describe un escenario de aplicación del patrón.
%  \item \emph{Aplicabilidad}: cuando se puede emplear el patrón.
%  \item \emph{Estructura}: Diagramas de clases que lo describe.
%  \item \emph{Participantes}: clases y objetos participantes en el diseño y sus repsonsabilidades.
%  \item \emph{Colaboraciones}: describe las interrelaciones que se dan entre los participantes.
%  \item \emph{Consecuencias}: como soporta los objetivos y ventajas y desventajas.
%  \item \emph{Implementación}: consejos de cara a la implementación del patrón.
%  \item \emph{Código de ejemplo}.
%  \item \emph{Usos conocidos}: ejemplos de sistemas reales de utilización.
%  \item \emph{Patrones relacionados}: con referencias a otros patrones.
%\end{itemize}



%Hay dos formas de clasificar los patrones de creación basándose en
%las clases de objetos que se crean. Una es clasificar las clases que
%crean los objetos (\underline {Factory Method}), otra forma está
%relacionada con la composición de objetos; definir un objeto que es
%responsable de conocer las clases de los objetos producto, en esta
%característica se apoyan los patrones \underline {Abstract Factory},
%\underline {Builder} o \underline {Prototype}. En muchas ocasiones
%los patrones de creación compiten en su función. Por ejemplo, hay
%casos donde \emph{Protoype} y \emph{Abstract Factory} puede utilizarse
%indistintamente. En otras ocasiones Builder puede usar a los otros
%patrones para implementar los componentes que construye.


Como ejemplo de patrón, el patrón \emph{Observer} define una
dependencia de \emph{uno a muchos} entre objetos, de modo que
cuando un objeto cambia de estado todos los objetos dependientes son
notificados y actualizados automáticamente. La \textit{motivación} de este patrón sería la reducción del acoplamiento entre clase de manera que un objeto puede notificar a
otros sin tener conocimiento de cuales objetos requieren la
notificación. Un uso de este patrón se da en las interfaces de usuario, donde unos
mismos datos pueden tener distintas vistas, y las distintas vistas son notificadas cuando los datos cambian. La estructura se pueden observar en diagrama de clases de la figura~\label{fig:diseno:patronObserver}. En Java ya se tiene implementada la clase
\texttt{Observer} y la interfaz \texttt{Observable}. La clase \texttt{java.util.Observable} es la clase abstracta \textit{Subject} del patron y cualquier clase que quiera ser
observada debe extender esta clase que proporciona métodos para
añadir, borrar y modificar \textit{observadores} que son guardados
en un tipo \textsf{Vector}. Las subclases sólo son responsables de
la llamada de notificación cuando el estado cambia, generalmente
dentro de una método ``\texttt{set\ldots(\ldots )}''. Un bosquejo de código implementando el patrón con las clases proporcionadas en Java sería algo así:

\begin{figure}%[htbp]
\centerline{\includegraphics[width=3.5in]{./5Diseno/figs/d51.eps}}%,height=3.21in
\caption{Patrón \texttt{Observer}}
\label{fig:diseno:patronObserver}
\end{figure}

%http://java-x.blogspot.com/2007/01/implementing-observer-pattern-in-java.html

\begin{small}
\begin{verbatim}
...

interface Subject {
 public void addObserver(Observer o);
 public void removeObserver(Observer o);
 public String getState();
 public void setState(String state);
}

interface Observer {
 public void update(Subject o);
}

class ObserverConcreto implements Observer {
 private String state = "";

 public void update(Subject o) {
   estado = o.getState();
   System.out.println("Nuevo estado" + estado);
 }
}
\end{verbatim}
\end{small}

%\begin{table}[htbp]
%\begin{tabular}
%{|p{426pt}|}
%\hline
%\par \texttt{\textbf{public java.util.Observable()}} \\
%\par \texttt{   Construct an Observable with zero Observers} \\
%\texttt{\textbf{public synchronized void addObserver(Observer o)}}\\
%\par \texttt{  Adds an observer to the set of observers of this
%object}\\
%
%\par \texttt{\textbf{public synchronized void deleteObserver(Observer o)}}\\
%\par \texttt{  Deletes an observer from the set of observers of this object} \\
%\par \texttt{\textbf{protected synchronized void setChanged()}} \\
%\par \texttt{  Indicates that this object has changed} \\
%\par \texttt{\textbf{protected synchronized void clearChanged()}} \\
%\par \texttt{  Indicates that this object has no longer changed, or that
%it has already notified all of its observers of its most recent change.
%his method is called automatically by notifyObservers()} \\
%\par \texttt{\textbf{public synchronized boolean hasChanged()}} \\
%\par \texttt{  Tests if this object has changed. Returns true if setChanged()
%has been called more recently than clearChanged()
%on this object; false otherwise.} \\
%\par \texttt{\textbf{public void notifyObservers(Object arg)}} \\
%\par \texttt{  If this object has changed, as indicated by the hasChanged()
%method, then notify all of its observers and then call the clearChanged()
%method to indicate that this object has no longer changed. Each observer
%has its update() method called with two arguments: this observable object
% and the arg argument. The arg argument can be used to indicate which
% attribute of the observable object has changed.} \\
% \par \texttt{\textbf{public void notifyObservers()}} \\
% \par \texttt{  Same as above, but the arg argument is set to null. That is,
% the observer is given no indication what attribute of the observable object
%  has changed.} \\
%\hline
%\end{tabular}
%\label{tab21}
%\end{table}
%
%
%
%
%
%
%La interfaz \texttt{java.util.Observer} debe ser implementada por
%cualquier clase \textit{observer}.
%
%\begin{table}[htbp]
%\begin{tabular}
%{|p{426pt}|}
%\hline
%The java.util.Observer Interface \\
%\hline
%\texttt{public abstract void update(Observable o, Object arg)} \\
%\hline
%\end{tabular}
%\label{tab22}
%\end{table}



%El metodo \texttt{update(\ldots )} es llamado cuando el objeto
%observado cambia como resultado de cambios clase ``vigilada'', que
%llamara al metodo \texttt{notifyObservers(\ldots )}.


%\begin{verbatim}
%/**
%* Ejemplo!
%*/
%public class ConcreteSubject extends Observable {
%  private String name;
%  private float price;
%
%  public ConcreteSubject(String name, float price) {
%    this.name = name;
%    this.price = price;
%    System.out.println("ConcreteSubject created: " + name + " at "
%+ price);
%  }
%
%  Public String getName() {return name;}
%
%  public float getPrice() {return price;}
%
%  public void setName(String name) {
%    this.name = name;
%    setChanged();
%    notifyObservers(name);
%  }
%
%  public void setPrice(float price) {
%    this.price = price;
%    setChanged();
%    notifyObservers(new Float(price));
%  }
%}
%
%// An observer of name changes.
%public class NameObserver implements Observer {
%  private String name;
%
%  public NameObserver() {
%    name = null;
%    System.out.println("NameObserver created: Name is " + name);
%  }
%
%public void update(Observable obj, Object arg) {
%  if (arg instanceof String) {
%    name = (String)arg;
%    System.out.println("NameObserver: Name changed to " + name);
%    } else {
%      System.out.println("NameObserver: Some other change to subject!");
%    }
%  }
%}
%// Test program for ConcreteSubject, NameObserver and PriceObserver
%public class TestObservers {
%  public static void main(String args[]) {
%    // Create the Subject and Observers.
%    ConcreteSubject s = new ConcreteSubject("Corn Pops", 1.29f);
%    NameObserver nameObs = new NameObserver();
%    PriceObserver priceObs = new PriceObserver();
%    // Add those Observers!
%    s.addObserver(nameObs);
%    s.addObserver(priceObs);
%    // Make changes to the Subject.
%    s.setName("Frosted Flakes");
%    s.setPrice(4.57f);
%    s.setPrice(9.22f);
%    s.setName("Sugar Crispies");
%  }
%}
%
%
%\end{verbatim}

%La siguiente tabla muestra todos los patrones definidos en el libro GoF:
%
%\begin{table}%[htbp]
%\begin{tabular}{|p{26pt}|p{400pt}|}
%\hline
%\raisebox{-7.50ex}[0cm][0cm]{\textbf{Patrones creacionales}}&
%\textbf{Patrones creacionales} \\
%\cline{2-2}
% &
%\textbf{Abstract Factory} (Fábrica abstracta): Permite trabajar con objetos de distintas familias de manera que las familias no se mezclen entre sí y haciendo transparente el tipo de familia concreta que se esté usando. \\
%\cline{2-2}
% &
%Builder (Constructor virtual): Abstrae el proceso de creación de un objeto complejo, centralizando dicho proceso en un único punto. \\
%\cline{2-2}
% &
%\textbf{Factory Method} (Método de fabricación): Centraliza en una clase constructora la creación de objetos de un subtipo de un tipo determinado, ocultando al usuario la casuística para elegir el subtipo que crear. \\
%\cline{2-2}
% &
%\textbf{Prototype} (Prototipo): Crea nuevos objetos clonándolos de una instancia ya existente. \\
%\cline{2-2}
% &
%\textbf{Singleton} (Instancia única): Garantiza la existencia de una única instancia para una clase y la creación de un mecanismo de acceso global a dicha instancia. \\
%\hline
% &
%\textbf{Patrones Estructurales } \\
%\hline
%\raisebox{-9.00ex}[0cm][0cm]{Estucturales}&
%\underline {Adapter} (Adaptador): Adapta una interfaz para que pueda ser utilizada por una clase que de otro modo no podría utilizarla. \\
%\cline{2-2}
% &
%\textbf{Bridge} (Puente): Desacopla una abstracción de su implementación. \\
%\cline{2-2}
% &
%\textbf{Composite} (Objeto compuesto): Permite tratar objetos compuestos como si de uno simple se tratase. \\
%\cline{2-2}
% &
%\textbf{Decorator} (Envoltorio): Añade funcionalidad a una clase dinámicamente. \\
%\cline{2-2}
% &
%\textbf{Facade} (Fachada): Provee de una interfaz unificada simple para acceder a una interfaz o grupo de interfaces de un subsistema. \\
%\cline{2-2}
% &
%\textbf{Flyweight} (Peso ligero): Reduce la redundancia cuando gran cantidad de objetos poseen idéntica información. \\
%\cline{2-2}
% &
%\textbf{Proxy}: Mantiene un representante de un objeto. \\
%\hline
% &
%\textbf{Patrones de Comportamiento} \\
%\hline
%\raisebox{-15.00ex}[0cm][0cm]{Patrones de Comportamiento}&
%\underline {Chain of Responsibility} (Cadena de responsabilidad): Permite establecer la línea que deben llevar los mensajes para que los objetos realicen la tarea indicada. \\
%\cline{2-2}
% &
%\textbf{Command} (Orden): Encapsula una operación en un objeto, permitiendo ejecutar dicha operación sin necesidad de conocer el contenido de la misma. \\
%\cline{2-2}
% &
%\textbf{Interpreter} (Intérprete): Dado un lenguaje, define una gramática para dicho lenguaje, así como las herramientas necesarias para interpretarlo. \\
%\cline{2-2}
% &
%\textbf{Iterator} (Iterador): Permite realizar recorridos sobre objetos compuestos independientemente de la implementación de estos. \\
%\cline{2-2}
% &
%\textbf{Mediator} (Mediador): Define un objeto que coordine la comunicación entre objetos de distintas clases, pero que funcionan como un conjunto. \\
%\cline{2-2}
% &
%\textbf{Memento} (Recuerdo): Permite volver a estados anteriores del sistema. \\
%\cline{2-2}
% &
%\textbf{Observer} (Observador): Define una dependencia de uno-a-muchos entre objetos, de forma que cuando un objeto cambie de estado se notifique y actualicen automáticamente todos los objetos que dependen de él. \\
%\cline{2-2}
% &
%\underline {State} (Estado): Permite que un objeto modifique su comportamiento cada vez que cambie su estado interno. \\
%\cline{2-2}
% &
%\textbf{Strategy} (Estrategia): Permite disponer de varios métodos para resolver un problema y elegir cuál utilizar en tiempo de ejecución. \\
%\cline{2-2}
% &
%\textbf{Template Method} (Método plantilla): Define en una operación el esqueleto de un algoritmo, delegando en las subclases algunos de sus pasos, esto permite que las subclases redefinan ciertos pasos de un algoritmo sin cambiar su estructura. \\
%\cline{2-2}
% &
%\textbf{Visitor} (Visitante): Permite definir nuevas operaciones sobre una jerarquía de clases sin modificar las clases sobre las que opera. \\
%\hline
%\end{tabular}
%\label{tab23}
%\end{table}

Otros ejemplos de patrones muy conocidos incluyen el patron \emph{Strategy}, también conocido como \emph{Policy pattern}, que es utilizado para implementar distintos algoritmos que compartan la interfaz pero puedan utilizarse indistintamente, con la ventaja de que se puede cambiar de algoritmo dinámicamente (ver figura \ref{fig:diseno:patronStrategy}). El patrón \emph{Composite} es utilizado para construir jerarquías de objetos que comparten una interfaz en la que unos elementos pueden formar parte de otros (por ejemplo, el las interfaces de usuario las ventanas se componen de paneles, botones campos de texto, etc. y a su vez por ejemplo los botones de una etiqueta de texto y una imagen). Otro patrón conocido es \emph{Iterator} que nos permite recorrer los elementos de una clase contenedora de objetos (como puede ser un \texttt{Vector}) sin conocer su implementación; un  ejemplo de su uso es la interface \texttt{java.util.Enumeration} como se muestra a continuación el el caso de tener una colección de \texttt{String}s:

\begin{small}
\begin{verbatim}
Enumeration e = vector.elements();
while (e.hasMoreElements())
  String s = (String) e.nextElement();
  System.println(s);
}
\end{verbatim}
\end{small}

\begin{figure}%[htbp]
\centerline{\includegraphics[width=4.5in]{./5Diseno/figs/StrategyPattern.eps}}%,height=3.21in
\caption{Patrón \texttt{Strategy}}
\label{fig:diseno:patronStrategy}
\end{figure}




Además, se puede hacer una reseña al concepto de
\textit{antipatrón}, que aunque se describen de manera semejante a
la de un patrón, lo intentan es prevenir contra errores comunes en
el diseño del software. Los antipatrones intentan detallar problemas
que acarrean ciertos diseños muy comunes y que a primera vista
correctos, pero que a la larga las desventajas superan los
beneficios. Los antipatrones definen pueden definirse a distintos niveles, y por
ejemplo, se han detallado antipatrones de gestión. Sin embargo, a nivel de diseño, los antipatrones puede clasificarse como \textit{refactorizaciones}, las cuales se describen en la sección \ref{} del capítulo \ref{mantenimiento} sobre mantenimiento .


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%\subsection{Refactorización}
%\label{diseno:refactorizacion}
%
%Refactorización (\emph{refactoring}) consiste en modificar el código o
%diseño sin que cambie su funcionalidad para hacerlo más flexible,
%robusto, entendible, fácil de mantenimiento, etc.
%
%\begin{table}[htbp]
%\begin{tabular}{|p{5in}|}
%\hline
%Definición -- \cite{Fowler:2000} \\
%\hline
%La refactorización es el proceso de cambio en un sistema software
%de tal modo que no altera el comportamiento externo del código, pero mejora
% su estructura interna. Es un método disciplinado para limpiar el código y
% minimizar las posibilidades de introducir nuevos errores.
% En esencia, cuando aplicamos una refactorización, estamos mejorando el diseño
% del código después de que este ya haya sido escrito. \\
%\hline
%\end{tabular}
%\label{tab24}
%\end{table}
%
%La refactorización, generalmente descrito como patrones, ayuda a los
%desarrolladores a reconstruir una estructura de un código para mejorar o limpiarlo, para hacer su mantenimiento más fácil y veloz. En esta labor, nosotros definimos un conjunto de
%pasos y reglas para adaptar las aserciones durante el proceso de
%refactorización. Dado que no hay una completa
%definici$\backslash $'on de todos las posibles refactorizaciones
%existentes (y esto es imposible, ya que nuevos tipos de
%refactorización se están desarrollando continuamente
%para solucionar nuevos problemas) el objetivo de este proyecto no es
%tanto definir un conjunto de reglas para cada uno de las
%refactorizaciones existentes, sino detallar algunos de los más
%importantes y hacer una clasificación general para dar
%un patrón de cómo actuar para adaptar
%las aserciones en las nuevas refactorizaciones que aparezcan en el
%tiempo.
%
%
%La razones que Fowler \cite{Fowler:2000} cita para usar técnicas de
%refactorización incluyen: (i) mejora el diseño del software; (ii)
%hace que el software sea más fácil de entender; (iii) nos ayuda a
%encontrar errores, y (iv) nos ayuda a programar más rápido.
%
%
%Los refactorings están relacionados con la orientación a objetos y
%patrones de diseño. Fowler ha propuesto un catálogo de de
%transformaciones de código donde se reconoce lo que Fowler denomina
%código maloliente (también conocidos como antipatrones), es decir,
%malas prácticas en programación como podrían ser el código duplicado
%o casi duplicado, métodos muy largo, etc. Este catálogo de
%transformaciones esta descrito al estilo de los patrones de diseño
%con una plantilla con los siguientes ítems:
%
%\begin{itemize}
%  \item Nombre para construir un vocabulario de \textit{refactoring} que
%pueda ser conocido por la comunidad.
%
%  \item Un resumen con contextos y que lo que hace el \textit{refactoring}.
%
%  \item Los mecanismos con una descripción paso a paso de cómo llevar a cabo
%el \textit{refactoring}.
%
%\end{itemize}
%
%
%%
%%El ejemplo más sencillo que se puede poner es el siguiente: si dentro
%%de una misma clase nos \textit{hiede} el código duplicado o casi
%%duplicado de varios métodos, podríamos aplicar el
%%\textit{refactoring} llamado \textit{Extract Method}, extrayendo la
%%parte de código duplicado en un método privado. El mismo
%%\textit{refactoring} podría aplicarse si tenemos nos mal un
%%método muy largo (en la orientación a objetos, se considera
%%que clases o métodos muy largos hacen demasiadas cosas y
%%deberían romperse en métodos más pequeños). Aunque
%%estos pueden parecer sencillos, los mecanismos paso a paso nos
%%permiten llevar a cabo los cambios sin `romper' otras partes del
%%sistema.
%%
%
%
%
%%\begin{table}[htbp]
%%\begin{scriptsize}
%%\begin{tabular}
%%{|p{200pt}|p{5pt}|p{204pt}|} \hline \texttt{void printOwing() {\{}}
%%\par \texttt{Enumeration e = {\_}orders.elements();} \par
%%\texttt{double outstanding = 0.0;} \par \texttt{// print banner}
%%\par \texttt{System.out.println(``*************'');} \par
%%\texttt{System.out.println(``* Cust Owes *'');} \par
%%\texttt{System.out.println(``*************'');} \par \texttt{//
%%calculate outstanding} \par \texttt{while(e.hasMoreElements()) {\{}}
%%\par \texttt{Order ord = (order)e.nextElement();} \par
%%\texttt{outstanding +=each.getAmount();} \par \texttt{{\}}} \par
%%\texttt{// print details} \par \texttt{System.out.println(``Name:''
%%+ {\_}name);} \par \texttt{System.out.println(``Amnt:'' +
%%outstanding);}
%%
%%\par & &
%%\texttt{void printBanner() {\{}} \par \texttt{System.out.println(``****** *****'');} \par \texttt{System.out.println(``*Cust Owes *'');} \par \texttt{System.out.println(``************'');} \par \texttt{{\}}} \par \texttt{double getOutstanding() {\{}} \par \texttt{Enumeration e = {\_}ords.elements();} \par \texttt{double result = 0.0;} \par \texttt{while(e.hasMoreElements()) {\{}} \par \texttt{Order ord = (order)e.nextElement();} \par \texttt{result +=each.getAmount();} \par \texttt{{\}}} \par \texttt{return result;} \par \texttt{{\}}} \par \texttt{void printDetails(double outstanding) {\{}} \par \texttt{System.out.println(``name:'' + {\_}name);} \par \texttt{System.out.println(``Amnt:'' + outstanding);} \par \texttt{{\}}} \par \texttt{} \\
%%\hline
%%\end{tabular}
%%\end{scriptsize}\label{tab25}
%%\end{table}
%
%
%
%%La principal propiedad de la refactorización es la
%%preservación en el comportamiento del c$\backslash $'odigo,
%%por lo que antes de nada, deber$\backslash $'iamos tener una clara idea de
%%lo que significa. En su tesis, Opdyke$\sim \backslash $cite{\{}Opdy92{\}}
%%defini$\backslash $'o y demostr$\backslash $'o la preservación
%%del comportamiento de un código a trav$\backslash $'es del
%%proceso de refactorización. Siguiendo la definición de Opdyke$\sim \backslash $cite{Opdy92}, el comportamiento es preservado cuando despu$\backslash $'es de la refactorizaci$\backslash $'on:
%%(a) Hay una $\backslash $'unica superclase (b) Las clases tienes nombres
%%distintos (c) La funciones y miembros dentro de una misma clase deben tener
%%nombres diferentes (d) En la redefinici$\backslash $'on de funciones, las
%%signaturas deben ser compatibles (para preservar el principio de
%%substitución de Liskov (LSP)$\sim \backslash
%%$cite{\{}Liskov94{\}}) (e) Las asignaciones deben conservar el tipo (f) Las
%%referencias y operaciones deben ser $\backslash $textit{\{}sem$\backslash
%%$'anticamente equivalentes{\}}$\backslash $footnote{\{}Opdyke
%%defini$\backslash $'o la equivalencia sem$\backslash $'antica de este modo:
%%supongamos que la interfaz externa del programa sea v$\backslash $'ia la
%%funci$\backslash $'on main. Si la funci$\backslash $'on main es llamada dos
%%veces (una antes y la otra despu$\backslash $'es de la
%%refactorizaci$\backslash $'on) con el mismo conjunto de entradas, hemos de
%%obtener el mismo conjunto de valores de salida.{\}}
%%
%%
%%A pesar de que la refactorizaci$\backslash $'on sea una herramienta muy
%%poderosa, no podemos aplicarlo bajo cualquier circunstancia. Opdyke$\sim
%%\backslash $cite{\{}Opdy92{\}} defini$\backslash $'o una serie de
%%precondiciones para cada tipo de refactorizaci$\backslash $'on, las cuales
%%deben ser cumplidas para preservar el comportamiento del programa a
%%trav$\backslash $'es del proceso de refactorizaci$\backslash $'on. Opdyke
%%los dividi$\backslash $'o en dos grandes categor$\backslash $'ias: (i)
%%$\backslash $textit{\{}low-level refactorings (refactorizaciones de
%%bajo-nivel){\}}, la preservaci$\backslash $'on del comportamiento de los
%%cuales es f$\backslash $'acil de demostrar si sus precondiciones son
%%respetadas y (ii) $\backslash $textit{\{}composite refactorings
%%(refactorizaciones compuestas){\}} los cuales se construyen con los de
%%bajo-nivel. Dado que las compuestas est$\backslash $'an construidos usando
%%refactorizaciones que preservan el comportamiento, el comportamiento
%%estar$\backslash $'a preservado tambi$\backslash $'en con ellos si las
%%precondiciones no se violan.
%
%
%Por ejemplo, cuando en un trozo de código vemos que existe código duplicado en distintos métodos
%
%
%%
%%
%%Bad smell: Duplicated code
%%Same expression in two methods in the same class?
%%Make it a private ancillary routine and parameterise it
%%Refactoring: \textbf{Extract method}
%%Same code in two related classes?
%%Refactoring: \textbf{template method}
%%Push commonalities into closest mutual ancestor and parameterize
%%Same code in two \textit{unrelated} classes?
%%Ought they be related?
%%Refactoring: \textbf{Extract class, Pull up method}:
%%Introduce abstract parent
%%Does the code really belongs to just one class?
%%Refactoring: Extract method: Make the other class into a client
%%Etc\ldots
%%Bad smell: Long method
%%Usually means:
%%Trying to do too many things
%%Poorly thought out abstractions and boundaries
%%Think carefully about the major tasks and how they inter-relate
%%Refactoring: Extract method
%%Break up into smaller private methods within the class
%%Refactoring: Extract class/method
%%Replace data value with object
%%Delegate subtasks to subobjects that `know best'
%%Otros
%%Long method
%%Fowler's heuristic: When you see a comment, make a method
%%Large class
%%\noindent
%%too many different subparts and methods
%%
%%Long parameter list
%%
%%It make methods difficult for clients to understand
%%
%%Switch statements
%%
%%This is an example of a lack of understanding polymorphism and a lack of
%%encapsulation.
%%
%%Solution: Replace conditional with polymorphism, replace type code with
%%subclasses
%%
%%Etc\ldots
%%
%%
%
%
%
%Además evidentemente están de están relacionado con el mantenimiento
%ya que los \textit{refactoring} formas de mantenimiento preventivo,
%al reestructurar tanto el diseño como el código (ver Sección
%8.7?`??? donde se clasifican los distintos tipos de mantenimiento).
%Finalmente, los \textit{refactoring} también son una de las
%actividades básicas de la metodología ágil XP (ver Sección
%\ref{procesos:xp}, ya que ayuda en la comprensión del código,
%generar pruebas y programar más rápido.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Software \emph{frameworks}, \emph{plug-ins} y componentes}
\label{subsec:software}

Obviamente es mucho mejor la reutilización a nivel de arquitecturas
y diseños que no a nivel de clases. Los patrones de diseño nos
permiten reutilizar un pequeño número de clases en conjunto, los
frameworks, plug-ins y componentes van más allá, permitiéndonos
reutilizar diseños y arquitecturas enteras para dominios concretos.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Marcos de trabajo (\emph{Frameworks})}

\begin{tabular}{|p{5in}|}
\hline
Definición \\
\hline
Un \emph{framework} es un conjunto de clases, interfaces y sus relaciones que proporcionan un diseño reusable para un sistema software o parte de un sistema (subsistema) de forma que sea extendido en una aplicación final.\\
\hline
\end{tabular}
\label{tab26}


Un \emph{framework} es por tanto, un conjunto de clases y sus relaciones
diseñado específicamente para ser extendido y no como aplicación
final. Abstrae las entidades, estados y comportamientos en un dominio. Los \textit{frameworks}
proporcionan unos puntos de extensión, denominados
\textit{hot-spots} en inglés. La idea es proporcionar toda la
funcionalidad genérica que se pueda y mostrar a los desarrolladores
las interfaces (APIs -- \emph{Application Program Interface}) a extender
para que sólo tengan que centrarse en lo específico de la
aplicación. El ejemplo más típico y el origen de los
\textit{frameworks} está en las interfaces de usuario (GUIs), donde el
usuario se centra en desarrollo de la interfaz abstrayéndose de cómo
se implementan los sus distintos componentes, botones, ventanas,
adornos, etc. Los \textit{frameworks} no necesitan tener una parte
visual, por ejemplo de framework, que se explica con cierto detalle
en el capítulo \ref{pruebas} es \texttt{JUnit}, un framework para pruebas
unitarias. Hoy día, los lenguajes de programación van acompañados de
\textit{frameworks} standards el desarrollo de aplicaciones se basa
en los \textit{frameworks} estándar proporcionados como parte del
lenguaje, por ejemplo, Java con el JDK (Java Development Kit) o Java
EE o C{\#} con la plataforma .NET. Como ejemplo final, están
surgiendo multitud de frameworks para el desarrollo de aplicaciones
Web con los típica estructura de bases de datos y operaciones sobre
ella, por ejemplo Apache Struts, Spring, etc. Generalmente, estos
\textit{frameworks} implementan un patrón muy general de alto nivel
conocido como MVC (\emph{Model-View-Controler}).

La motivación de desarrollar un \textit{framework}, se da cuando este va
a ser reutilizado en múltiples aplicaciones dándose una
reducción de costes a largo plazo, ya que el desarrollo del
\textit{framework} en si mismo es mucho más costoso que el
desarrollo de aplicaciones "normales". Además, en general, los \emph{frameworks} tienen una
larga curva de aprendizaje, por lo que en su diseño hay que llegar a un balance entra su simplicidad y la funcionalidad que proporciona. Es decir, el \textit{framework} debe ser lo
suficientemente simple como para que pueda ser aprendido por los
desarrolladores extendiendo sus \emph{hot-spots}, pero además debe suministrar
la funcionalidad suficiente para que \textit{framework} sea útil en
el domino para el que se ha diseñado.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{\emph{Plug-ins}}

Además de los \emph{frameworks}, las tendencias actuales para la mejora del
la reutilización, está en la creación de \textit{plug-ins}.


\begin{tabular}{|p{5in}|}
\hline
Definición \\
\hline
Un \textit{plug-in} es una aplicación completa, módulo o componente que interacciona con una aplicación anfitriona (\emph{host application}) extendiéndola o adaptando su comportamiento sin modificar la aplicación anfitriona. \\
\hline
\end{tabular}



Ejemplos de utilización diaria de plug-ins se dan el los navegadores
Web, extendiendo su funciona básica de mostrar páginas en HTML o XML
con terceras aplicaciones para ver documentos en pdf, videos,
música, etc. Otro ejemplo se da en el desarrollo del software con plataformas
genéricas, siendo las más conocidas son \textit{Eclipse}
\footnote{\texttt{http://www.eclipse.org/}} y \textit{Netbeans}
\footnote{\texttt{http://www.netbeans.org/}} que permiten que terceras partes
desarrollen aplicaciones con mucha de la funcionalidad ya proporcionada
por estas plataformas y sin necesidad de modificarlas. Aparte de los
aspectos técnicos, la no modificación de la plataforma anfitriona puede ser importante
desde el punto de vista legal por el tema de licencias.

La forma de implementar \textit{plug-ins} es mediante un patrón
denominado Inversión de control (IoC- \textit{Inversion of
Control}), que se suele describir con el lema de Hollywood:
\textit{``No nos llame, nosotros le llamaremos''}. La idea es que la
aplicación anfitriona no tenga que ser modificada, no tenga que
conocer los detalles de implementación del \textit{plug-in}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Componentes}

\begin{tabular}{|p{5in}|}
\hline
Definion -- \cite{Messerschmitt:2007}\\
\hline
Los \textbf{componentes} son elementos de funcionalidad vendidos
como una unidad e incorporados en múltiples usos. En la más pura
forma de composición, los sistemas son construidos enteramente de
componentes comprados (no localmente implementados) que son
ensamblados sin modificación. El valor de los componentes se da cuando
se ensamblan unos con otros componentes para formar un sistema como solución a medida. \\
\hline
\end{tabular}


La idea de los componentes de software se asemeja a la idea de
componentes hardware con elementos intercambiables. Los componentes de
software deben adherirse a una especificación que definen sus
interfaces de tal manera que loas aplicaciones puedan construirse
mediante la composición de interfaces o que terceras partes puedan
desarrollar componentes sin tener que mostrar el código fuente.
Ejemplos de componentes software son JavaBeans, Microsoft COM o componentes
CORBA.

Esta forma de desarrollar sistemas ha dado lugar a la
\textit{ingeniería del software basada en componentes} (CBSE --
\textit{Component based Software Engineering}) donde se deben
realizar una serie de tareas adicionales como puede ser la búsqueda,
evaluación, selección, comprar y reemplazo de componentes y adaptar
otras como pueden ser las pruebas. Esto ha dado lugar a que se
adapten metodologías considerando 3 actividades particulares:

\begin{itemize}

  \item \textit{Cualificación de componentes}: actividades de
análisis para evaluar cada componente.
  \item \textit{Adaptación de componentes}: procedimientos para que los componentes se adapten a la arquitectura
requerida.
  \item \textit{Composición de componentes}: donde los ingenieros de software deben considerar los mecanismos de
conexión y coordinación.
  \item \textit{Actualización de componentes}: actividades para reemplazar componentes, donde la no disposición del
código fuente, la compra a terceros y la dependencia de estos deben
considerarse.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\begin{tabular}{|p{5in}|}
\hline
Diferencias entre bibliotecas de funciones, \emph{frameworks}, \emph{plug-ins} y componentes\\
\hline
\begin{itemize}
  \item Las \emph{bibliotecas de funciones} no tienen incorporado ningún flujo de control, se componen de clases o funciones que son llamadas para realizar una funcionalidad específica, por ejemplo, una biblioteca de funciones matemáticas.

  \item Los \textit{frameworks} ya tienen diseñando una arquitectura y un flujo de control;
están pensadas como aplicaciones incompletas diseñadas para ser
extendidas.
  \item Los patrones de diseño se asemejar a los \textit{frameworks}, pero desde el punto de vista
lógico, y no de implementación como los \textit{frameworks}.

  \item Los \emph{componentes} están diseñados para ser piezas reemplazables, y la
idea es desarrollar aplicaciones mediante composición.

  \item Los \textit{plug-ins} se asemejan a los componentes, pero están diseñados para que
sean llamados desde una aplicación anfitriona.
\end{itemize}
\\\hline
\end{tabular}



%\subsection{Frameworks vs. Plug-ins vs. Componentes vs.
%Bibliotecas}
%
%A continuación se resumen las características especificas de cada
%una de las formas de desarrollo vistas en esta sección:
%
%
%\begin{itemize}
%  \item Las bibliotecas de funciones es que una biblioteca se compone de clases o
%funciones que son llamadas para realizar una funcionalidad
%específica, no contienen ningún flujo de control.
%  \item Los \textit{frameworks} ya tienen diseñando una arquitectura y un flujo de control;
%están pensadas como aplicaciones incompletas diseñadas para ser
%extendidas.
%  \item Los patrones de diseño se asemejar a los \textit{frameworks}, pero desde el punto de vista
%lógico, y no de implementación como los \textit{frameworks}.
%
%  \item Los componentes están diseñados para ser piezas reemplazables, y la
%idea es desarrollar aplicaciones mediante composición.
%
%  \item Los \textit{plug-ins} se asemejan a los componentes, pero están diseñados para que
%sean llamados desde una aplicación anfitriona.
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Diseño por contratos}
\label{subsec:disenoContratos}

Meyer~\citeyear{Meyer99} creo la noción de diseño por contratos
(\emph{Design by Contract}) en el contexto del la
construcción de software orientado a objetos. Cada método tiene una precondición y una postcondición que esperan ser cumplidas respectivamente en la entrada y salida de la función.
Las aserciones puede ser usadas para comprobar dichas condiciones una clase y sus clientes como un acuerdo formal: "\emph{si tú, cliente, me
garantizas ciertas precondiciones, entonces yo, proveedor, generaré resultados correctos. Pero si de lo contrario, violas las precondiciones, no te prometo nada}".


La especificación de los contratos realiza por medio de aserciones como herramienta perfecta para expresar todos los derechos y obligaciones de cada una de las partes, del cliente con
precondiciones, y las obligaciones del proveedor con poscondiciones.

\begin{tabular}{|p{5in}|}
\hline
Definición -- \cite{Rosenblum:1995}\\
\hline
Las aserciones son restricciones formales en el comportamiento de un sistema
 software que comúnmente están escritas como anotaciones en el código
 fuente.\\
% El objetivo primordial de escribir aserciones es especificar quée se supone
% que un sistema debe hacer en lugar de cómo debe hacerlo.
\hline
\end{tabular}

%Meyer defini$\backslash $'o el dise$\backslash \sim $no-por-contrato
%con la pretensi$\backslash $'on de ser la mejor metodolog$\backslash
%$'ia para construir software fiable. Meyer define fiabilidad como
%correctitud y robustez. Meyer afirma que antes del dise$\backslash
%\sim $no-por-contrato la $\backslash $'unica forma para asegurar
%esta propiedad era $\backslash $textit{\{}confiando que sus autores
%hab$\backslash $'ian aplicado todo el cuidado necesario, incluyendo
%una etapa de t$\backslash $'ecnicas de validaci$\backslash $'on y
%test extensivas{\}}$\sim \backslash $cite{\{}Meye97{\}}. Si usamos
%dise$\backslash \sim $no-por-contrato tenemos una
%definici$\backslash $'on formal de correctitud de una clase, y una
%m$\backslash $'etodo para asegurarse que una clase es correcta:
%$\backslash $textit{\{}Una clase como cualquier otro elemento de
%software, es correcta o incorrecta no por s$\backslash $'i misma,
%sino con respecto a una especificaci$\backslash $'on. Introduciendo
%precondiciones, poscondiciones e invariantes incluimos una parte de
%la especificaci$\backslash $'on dentro de la clase misma. Esto nos
%da una base que tasa la correctitud: la clase es correcta si y
%solamente si su implementaci$\backslash $'on, dada por los cuerpos
%de rutina, es consistente con las precondiciones, poscondiciones e
%invariantes{\}} {\%}(p$\backslash $'agina 369).

%
%[...] $\backslash $textit{\{}Si una clase est$\backslash $'a
%equipada con aserciones, es posible definir formalmente
%qu$\backslash $'e significa para la clase ser correcta{\}}$\sim
%\backslash $cite{\{}Meye97{\}}.

Las \emph{aserciones} fueron creadas por Hoare como un sistema de
axiomas para demostrar la correctitud de programas Algol
\cite{Hoare:1969}. Además, dado que podemos expresar suposiciones del
estado del programa durante la ejecución, podemos usar las
aserciones como un modo de documentación, con la ventaja de que seremos notificados en
el caso que nuestras suposiciones sobre el código no fueran ciertas.
Siguiendo esta idea, podemos definir las especificaciones de un
software OO, incluso antes de tener el código implementado,
expresando sus precondiciones y poscondiciones de métodos. Además,
como las aserciones son un modo de verificar nuestras suposiciones
en cualquier punto del código, también podemos detectar errores de
implementación. Podemos ahorrarnos una gran parte del tiempo de
pruebas que gastaríamos buscando un error, ya que un fallo en la
aserción nos devuelve información detallada sobre dicho error. Esta verificación tendría la forma de: \texttt{\{Pre\} Código \{Post\}}, donde un ejemplo muy trivial donde se prueba la correctitud de un trozo de código sería: \texttt{\{a $\leq$ 0\} a++; \{a $\leq$ 1\}}

%{\%}A pesar de que Rosenblum observ$\backslash $'o que no exist$\backslash
%$'ia una clara correlaci$\backslash $'on entre la localizaci$\backslash $'on
%de un error y el lugar donde estaba situada la aserci$\backslash $'on que lo
%detectaba$\sim \backslash $cite{\{}Rose95{\}}, Satpathy et al$\sim
%\backslash $cite{\{}Satpathy04{\}} (durante la realizaci$\backslash $'on
%de un proyecto software) demostraron que poner las aserciones en puntos
%clave era muy frecuentemente de gran ayuda para localizar un error dado. A
%consecuencia de ello, programar con aserciones puede llevarnos a tener
%nuestros programas ejecut$\backslash $'andose m$\backslash $'as r$\backslash
%$'apidamente y con un mayor grado de confianza sobre la correctitud del
%programa.
%
%
%Rosenblum$\sim \backslash $cite{\{}Rose95{\}} clasific$\backslash $'o las
%aserciones en el contexto de mantenimiento y testeo de software en dos
%categor$\backslash $'ias principales: (a) La especificaci$\backslash $'on de
%interfaces de funci$\backslash $'on; (b) La especificaci$\backslash $'on de
%cuerpos de funci$\backslash $'on. La primera categor$\backslash $'ia de
%aserciones, describe el comportamiento de una funci$\backslash $'on,
%independientemente de su implementaci$\backslash $'on ($\backslash
%$textit{\{}visi$\backslash $'on de caja-negra{\}}), mientras la segunda
%procura asegurar su correcta implementaci$\backslash $'on ($\backslash
%$textit{\{}visi$\backslash $'on de caja-blanca{\}}).
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Diseño de sistemas distribuidos}
\label{subsec:sistemasDistribuidos}

Los sistemas distribuidos se encuentran en todos los ámbitos de la
vida, redes de ordenadores, sistemas de telefonía móvil,
robots industriales, coches, aviones, trenes, etc. En esta sección
se comenta brevemente las características de los sistemas
distribuidos y como estas impactan en el diseño de sistemas y sus
implementaciones. Además los sistemas distribuidos tienen conceptos
y técnicas particulares.


\begin{table}[htbp]
\begin{tabular}{|p{5in}|}
\hline
Definición \cite{Coulouris:EtAl:2001}\\
\hline
Un \textbf{sistema distribuido} es un sistema en el cual los components de
 hardware o software localizados en una red de ordenadores se comunican y
 coordinan sus acciones únicamente mediante el paso de mensajes. \\
\hline
\end{tabular}
\label{tab30}
\end{table}

Otra definición quizás más sencilla es la de Tanenbaum y van Steen \citeyear{Tanenbaum:vanSteen:2006}: "Un sistema distribuido es una colección de ordenadores independientes que se
comportan como un único ordenador de cara al usuario". La diferencia entre redes de computadores y los sistemas distribuidos es el nivel el que se encuentran. Mientras que las redes de
computadores se centran el la interconexión y el envío de información por medio de paquetes, la rutas de los datos, direcciones IP, etc., los sistemas distribuidos muestran al usuario
de forma transparente un conjunto de computadores trabajando de forma autónoma en una misma aplicación. Las motivaciones al crear sistemas distribuidos son varias:

\begin{itemize}
  \item Funcional donde la distribución de la información es inherente al
sistema (Web, correo, sistemas de compra-venta cliente/servidor,
etc.)
  \item Distribución y balanceo de carga en servidores.

  \item Fiabilidad, donde se pueden tener sistemas redundantes y backups en
diferentes localizaciones.

  \item Económicas, con la construcción de ordenadores potentes a
base de clusters de ordenadores más asequibles, o compartición de
recursos como impresoras, backups, etc.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsection{Propiedades de los sistemas distribuidos}
%\label{subsubsec:mylabel8}
%
Un sistema distribuido puede ser desde un \emph{cluster} de computadoras
homogéneas en una red local y en una misma oficina hasta un sistema
de ordenadores completamente heterogéneos (capacidades, sistemas
operativos, etc.) distribuidos por distintos países y comunicándose
a través de múltiples redes (wireless, Ethernet, ATM, etc.). Las
consecuencias son que los sistemas distribuidos deben tener en
cuenta incluyen:

\begin{description}
  \item[Concurrencia] Proporcionar y gestionar los accesos concurrentes a los recursos
compartidos. En los sistemas distribuidos se debe gestionar
ordenadores autónomos trabajando en paralelo y coordinando tareas
teniendo en cuenta la no existencia de un ``reloj'' global en la
comunicación, preservando las dependencias, evitando puntos muertos
y proporcionando un acceso justo a los recursos.

  \item[Heterogeneidad] Multiples tipos de ordenadores, redes y sistemas operativos que
obliga a la creación de protocolos abiertos para su permitir su
comunicación por paso de mensajes.

  \item[Transparencia] La distribución debería ocultarse de los usuarios y a los
desarrolladores. Hay diferentes tipos:


\begin{itemize}
  \item \emph{Transparencia en el acceso}: el acceso a ficheros locales o remotos
debería ser idéntico (p.e., sistemas de ficheros en red).

  \item \emph{Transparencia en la localización}: la aplicación distribuida
debería de permitir el acceso a los recursos independientemente de
donde se encuentren (p.e., los servicios Web o CORBA pueden
dinámicamente descubrir e invocar servicios independientemente de
localización).

\end{itemize}

\item[Tolerancia a fallos] Los sistemas distribuidos necesitan recuperarse
de forma transparente a fallos en cualquiera de los componentes de
un sistema distribuido. Para ello deben de implementar mecanismos de
detección de fallos, enmascaramiento de fallos, tratamiento de
excepciones, recuperación de fallos con mecanismos de
\textit{rollback}, etc.

\item[Escalabilidad] Los sistemas distribuidos deberían funcionar
eficientemente cuando se incrementa el número de usuarios o escalar
la eficiencia acorde al número de recursos nuevos que se ponen en la
red.


\item[Seguridad] El sistema distribuido debería de ser usado
solamente de la manera que se diseño para mantener la
confidencialidad, que individuos no accedan a información no
autorizada, integridad, protección contra la alteración o corrupción
de información, disponibilidad contra ataques y el no-repudio
mediante pruebas de envío y recepción de la información. Esto se
consigue mediante los mecanismos de encriptación, autentificación y
autorización.


\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%\subsubsection{Tecnologías para sistemas distribuidos}
%
Dentro de los estilos arquitecturales que hemos comentado, los que
se pueden englobar dentro de los sistemas distribuidos incluyen
cliente-servidor, \emph{peer-to-peer} y \emph{grid}. Existe una variedad de tecnologías para implementar dichos estilos arquitecturales entre los que se encuentran:

\begin{itemize}
  \item Un \textbf{servicio Web} es un sistema software identificado por una URI (Uniform Resource Identifier), cuyas interfaces públicas y puntos de enlace (\emph{bindings}) están definidos y descritos en XML. Su definición puede ser descubierta por sistemas software. Estos sistemas pueden entonces interactuar con el servicio Web de la forma prescrita en su definición, utilizando mensajes basados en XML llevados a cabo por protocolos de Internet \cite{}.


  \item \textbf{CORBA} (Common Request Broker Architecture) es un \textit{middleware} para la programación concurrente de sistemas distribuidos mediante la orientación a objetos. CORBA proporciona una plataforma para invocar objetos en servidores remotos, que pueden encontrarse en la misma maquina o a través de redes. Utilizando CORBA, una clase puede transparentemente invocar a métodos de otras clases sin saber su localización (en que máquina se encuentra dicha clase).

  \item Otras tecnologías que permiten implementar sistemas distribuidos aunque específicas a lenguajes de programación o plataformas se encuentran \textbf{RMI} (\emph{Remote Method Invocation}) en Java o \textbf{DCOM} (\emph{Distributed Component Object Model}) en Microsoft Windows.
\end{itemize}



%\begin{tabular}{|p{5in}|}
%\hline
%Definición -- Servicios Web \\
%\hline
%Un \textbf{servicio Web} es un sistema software identificado por una URI (Uniform Resource Identifier), cuyas interfaces públicas y puntos de enlace (\emph{bindings}) están definidos y descritos en XML. Su definición puede ser descubierta por sistemas software. Estos sistemas pueden entonces interactuar con el servicio Web de la forma prescrita en su definición, utilizando mensajes basados en XML llevados a cabo por protocolos de Internet. \cite{}\\
%\hline
%\end{tabular}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsubsection{CORBA}
%\label{subsubsec:corba}

%CORBA (Common Request Broker Architecture) es un \textit{middleware}
%para la programación concurrente de sistemas distribuidos mediante
%la orientación a objetos. CORBA proporciona una plataforma para
%invocar objetos en servidores remotos, que pueden encontrarse en la
%misma maquina o a través de redes. Utilizando CORBA, una clase puede transparentemente invocar a
%métodos de otras clases sin saber su localización (en que máquina se encuentra dicha clase).


%Un ORB intercepta
%las llamadas y es responsable de encontrar el objeto que implementa
%la petición independientemente de los lenguajes de programación,
%arquitecturas hardware y protocolos de red. De hecho, solamente
%necesita saber su interfaz. La figura ?`??? muestra un sistema
%distribuido basado en CORBA y en la arquitectura de referencia OMA
%(\textit{Object Management Architecture}) del OMG (Object Management
%Group -- también encargado de los estándares de UML --
%\texttt{http://www.omg.org/}). Se distinguen los siguientes
%elementos:
%
%\begin{itemize}
%
%  \item \emph{Object Services} son interfaces para servicios generales utilizados por la mayoría de
%las aplicaciones distribuidas.
%
%  \item \emph{Common Facilities} son interfaces horizontales definidas el
%usuario para el usuario final y aplicables en la mayoría de los
%dominios.
%
%  \item \emph{Domain Interfaces} are application domain-specific interfaces.
%
%  \item \emph{Application Interfaces} son interfaces no estandarizadas del
%dominio de la aplicación.
%
%\end{itemize}
%
%
%\begin{figure}[htbp]
%\centerline{\includegraphics[width=4.65in,height=2.62in]{./5Diseno/figs/d52.eps}}
%\label{fig52}
%\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Evaluación y métricas en el diseño}
\label{diseno:subsec:evaluacion}

Los diseños necesitan ser evaluados de forma que puedan evaluarse distintos criterios de calidad y comparar distintas alternativas, ya que dada una especificación, pueden existir varios diseños perfectamente válidos pero con distintos criterios de calidad. Entre los criterios más importantes y que ya hemos visto en la sección \ref{diseno:subsec:modularidad} están los de cohesión y acoplamiento como medida de la modularidad de un sistema. Otros criterios más generales están relacionados con los modelos de calidad como se introdujeron en el capítulo \ref{medicion} y se describen en más detalle en el capítulo de \ref{calidad}. Estos modelos de calidad pueden generarse siguiendo GQM (ver~\ref{medicion:metodologias:gqm}), y como ejemplo de factores relevantes para el diseño :

\begin{itemize}
  \item \emph{Extensibilidad}. La capacidad de añadir nueva funcionalidad sin necesidad de cambios significativos en su arquitectura.

  \item \emph{Solidez}. la capacidad de operar bajo presión y tolerar~entradas
invalidas o impredecibles.

  \item \emph{Fiabilidad}. la capacidad de llevar a cabo la función requerida en las condiciones deseadas durante un tiempo especificado.

  \item \emph{Tolerancia a fallos}. el sistema debe robusto y capaz de recuperarse ante fallos.

%  \item Seguridad: la capaz de resistir intentos de acceder aplicaciones sin autorización.

%  \item Mantenibilidad: .

  \item \emph{Compatibilidad}. La capacidad de operar con otros productos
  y su adherencia a estándares de interoperabilidad.

  \item Reusabilidad. Relacionado con el concepto de modularidad, los componentes deberían de
  capturar la funcionalidad esperada, ni más ni menos y adherirse . Esta única
  finalidad, hace que los componentes sean reutilizables en otros diseños con
  idénticas necesidades.

\end{itemize}

Un tipo de validación, aunque menos común, es la validación matemática. Los diseños se pueden
validar matemáticamente si se ha seguido un una metodología formal en la especificación de requisitos. Si en el diseño de la arquitectura se ha especificado utilizando algún lenguaje formal de definición de arquitectura, pueden validarse y compararse distintas alternativas mediante herramientas especificas antes de su implementación definitiva.

Otras técnicas más comunes son las revisiones e inspecciones, que al igual que todas las demás fases del ciclo de vida, se pueden realizar unas reuniones llamadas revisiones o inspecciones de diseño
donde se analiza los artefactos que son generados en la fase correspondiente. Las revisiones de diseño se suelen clasificar según el nivel de detalle en:

\begin{itemize}
  \item Revisiones de diseño preliminares, donde se examinan el diseño
conceptual con los clientes y usuarios.
  \item Revisiones de diseño críticas, donde el diseño se presenta a
los desarrolladores.
  \item Revisiones del diseño del programa, donde los programadores
obtienen \emph{feedback} antes de la implementación. A estas reuniones también se las conoce como inspecciones (o \emph{walkthroughs} en si el moderador de la reunión es la persona que ha generado el diseño o programa, siendo generalmente más informales. \marginpar{Los métodos específicos de revisión de código se cubre en más detalle en la sección~\label{construccion:principios:verificar}}
\end{itemize}



%Parnas y Weiss describen una lista de ``requisitos'' a contemplar en
%una revisión de diseño.  Además, es normal tener una serie de preguntas
%en forma de "checklist" que se van analizando en la reunión. Para
%cualquiera de los 3 niveles del diseño, debe analizar
%
%
%\begin{itemize}
%  \item Bien estructurado -- consistente con los principio de ocultación
%de la información. ?`Es el diseño modular, bien estructurado y fácil
%de comprender? ?`Se puede mejorar la estructura y la facilidad de
%comprensión?
%
%  \item Simple, ?`es el diseño el más simple posible permitiendo llevar a cabo los
%requisitos?
%
%  \item Eficiente ?`son los algoritmos apropiados o pueden mejorarse? ?`Maximiza la eficiencia ahí
%  donde es posible?
%
%  \item Adequado ?`Es una solución al problema? ?`Cubre los requisitos?
%
%  \item Practical?????`Es migrable a otros entornos? ?`es reusable? ?`facilita las
%pruebas? ?`facilita la modificación? ?`reusa componentes de otros
%proyectos donde se puede?
%
%  \item Implementable ?`Puede realizarse con el software y hardware disponible?
%
% \item Estandarizado ?`se usa una notación bien definida y clara?
% ¿Esta el diseño bien documentado, argumentado la decisión
%escogida y comparándola con otras?
%\end{itemize}
%
%
%Además los diseños se pueden medir, existen multitud de métricas
%según el paradigma seguido y algunas se detallan a continuación.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Métricas el diseño}
%\label{diseno:metricas}

En la sección~\ref{diseno:conceptos:modularizacion} se han descritos los conceptos de cohesión y acoplamiento, siendo el objetivo más importante del diseño el maximizar la cohesión y minimizar el acoplamiento. Además, en el capítulo~\ref{medicion} algunas métricas relacionadas con la complejidad del código, en esta sección veremos algunos ejemplos de métricas relacionadas con la complejidad del diseño, prácticamente sinónimo de la complejidad estructural.

La medición de la complejidad estructural se realiza midiendo las llamadas entre módulos con los conceptos de \emph{fan-in} y \emph{fan-out} (ver figura~\ref{fig:diseno:fan-in-out}):
\begin{itemize}
  \item \emph{\textbf{Fan-in}}, o grado de dependencia, de un módulo es número de módulos que llaman a dicho módulo.
  \item \emph{\textbf{Fan-out}}, o grado de responsabilidad de coordinación, de un módulo es el número de módulos que son llamados por dicho módulo.
\end{itemize}


\begin{figure}
\begin{center}
    \epsfig{file=./5Diseno/figs/fan-in-out.eps} %, width=9cm
\end{center}
\caption{Conceptos de \emph{fan-in} y \emph{fan-out}}
\label{fig:diseno:fan-in-out}
\end{figure}

Un valor alto de \emph{fan-in} indica que el módulo está fuertemente acoplado por lo que cambios en el módulo afectarán resto del sistema. Valores altos de \emph{fan-out} pueden indicar módulos complejos debido a la complejidad de la lógica de control necesaria para coordinar las llamadas al módulos.

Basándose en estos conceptos de flujo de información, Henry y Kafura~\citeyear{Henry:Kafura:1981} una conocida métrica de la \textbf{complejidad estructural}:

\[
HK_m = C_m \cdot (fan-in_m \cdot fan-out_m)^2
\]

\noindent donde $C_m$ es la complejidad del módulo generalmente medida en $LoC$, aunque pueden considerarse otras como la complejidad ciclomática (ver \ref{medicion:complejidad})

Basándose en teoría de grafos, Fenton~\citeyear{Fenton:Plfeeger:1997} propone medidas de morfología de la estructura de módulos jerárquicos del sistema:
\begin{itemize}
  \item Tamaño = número de nodos + número de aristas
  \item Profundidad de anidamiento
  \item Anchura
  \item Proporción de arcos y nodos, número de arcos / número de nodos
\end{itemize}


%Métricas de complejidad propuestas por Card y Glass en 1990
%.. Complejidad estructural
%.. S(i) = f2
%out (i), donde
%.. fout (i) = expansión del módulo i (número de módulos
%inmediatamente subordinados al módulo i)
%.. Complejidad de Datos. Sobre la interfaz interna del
%módulo.
%.. D(i) = v(i) / [fout (i) + 1], donde
%.. v(i) es el número de variables que entran o salen del módulo.
%.. Complejidad del Sistema.
%.. C(i) = S(i) + D(i)
%
%A medida que crecen los valores de complejidad, crece
%la complejidad arquitectónica del sistema.


Dentro de la orientación a objetos, entre las métricas más conocidas son las conocidas como MOOD (\emph{Metrics for Object oriented Design}) definidas por Brito e Abreu y Melo~\citeyear{Brito:Melo:1996} y las de Chidamber y Kemerer~\citeyear{Chidamber:Kemerer:1994}. Estas métricas, en líneas generales, identifican clases mal diseñadas mediante mediciones de mecanismos estructurales básicos en el paradigma de la orientación a objetos como encapsulación, herencia, polimorfismo y paso de mensajes. Además, las métricas a nivel de sistema, y por ende si el sistema en general está bien diseñado, pueden derivarse de las métricas de a nivel de clase métricas usando la media u otros estadísticos. Entre las métricas MOOD podemos citar como ejemplos:

\begin{itemize}
  \item \textbf{Proporción de métodos ocultos} (MHF). Se define como la proporción del número de métodos definidos como protegidos o privados entre el total de métodos.  Esta métrica mide la encapsulación. %Method Hiding Factor

  \item \textbf{Proporción de atributos ocultos} (AHF) Es la proporción entre los atributos definidos como protegidos o privados y el número total de atributos. Aunque a veces por mejorar el rendimiento se acceden o modifican los atributos directamente, idealmente esta métrica debería ser 100{\%}, i.e., se deberían de tener todos los atributos privados y acceder a ellos mediante métodos \emph{get/set}. Esta métrica también mide la encapsulación.
      %Attribute Hiding Factor

  \item \textbf{Proporción de métodos heredados} (MIF). Se define como la proporción de la suma de todos los métodos heredados en todas las clases entre el número total de métodos (localmente definidos más los heredados) en todas las clases.
       %Method Inheritance Factor

  \item \textbf{Proporción de atributos heredados} (AIF). Se define como la proporción del número de atributos heredados entre el número total de atributos. AIF se considera un medio para expresar el nivel de reusabilidad en un sistema.
      %Attribute Inheritance Factor

  \item \textbf{Proporción de polimorfismo} (PF). PF se define como la proporción entre el número real de posibles diferentes situaciones polimórficas para una clase $C_{i}$ entre el máximo número posible de situaciones polifórficas en $C_{i}$. En otras palabras, el número de métodos heredados redefinidos dividido entre el máximo número de situaciones polimórficas distintas. PF es una medida del polimorfismo y una medida indirecta de la asociación dinámica en un sistema.
      %Polymorphism Factor
\end{itemize}

Al igual que las métricas MOOD, Chidamber y Kemerer~\citeyear{Chidamber:Kemerer:1994} han definido una serie de métricas que han sido ampliamente adoptadas para medir características como encapsulamiento, ocultamiento de información, herencia. Entre estas métricas tenemos:


\begin{itemize}
  \item\textbf{Acoplamiento entre objectos} (CBO). CBO de una clase es el número
        de clases a las cuales está ligada, es decir, usa métodos o variables de otra clase (medida del \emph{fan-out}). Las clases relacionadas por herencia no se tienen en cuenta. Sistemas en los cuales una clase tiene un alto CBO y todas las demás tienen valores próximos a cero indican una estructura no orientada a objetos, con una clase principal dirigente. Por el contrario, la existencia de muchas clases con un alto valor de CBO indica que el diseñador ha afinado demasiado la “granularidad” del sistema. Esta métrica además puede utilizarse para medir el esfuerzo en el mantenimiento y las pruebas. A mayor acoplamiento, mayor dificultad de comprensión y reuso, mantenimiento en acoplamiento se da en una clase, más difícil sera reutilizarla.
        Además, las clases con excesivo acoplamiento dificultan la comprensibilidad y hacen más difícil el mantenimiento por lo que será necesario un mayor esfuerzo y rigurosas pruebas.
        %Coupling Between Objects

   \item \textbf{Respuesta para una clase} (RFC) Esta métrica cuenta las ocurrencias de llamadas a otras clases desde una clase particular y mide tanto la comunicación interna como la externa. RFC es una medida de la
        complejidad de una clase a través del número de métodos y de la
        comunicación con otras clases.
        %Response For a Class

   \item \textbf{Profundidad en árbol de herencia} (DIT). Mide el máximo nivel en la jerarquía de herencia. DIT es la cuenta directa de los niveles en la jerarquía de herencia. En el nivel cero de la jerarquía se encuentra la clase raíz. A medida que crece su valor, es más probable que las clases de niveles inferiores hereden muchos métodos y esto da lugar a posibles dificultades cuando se intenta predecir el comportamiento de una clase y por lo tanto, su mantenimiento. Una jerarquía profunda conlleva también una mayor complejidad de diseño. Por otro lado, los valores grandes de DIT implican que se pueden reutilizar muchos métodos, lo que debe ser considerado como un elemento a favor de la mantenibilidad.
       %Depth of Inheritance Tree

   \item \textbf{Número de descendientes} (NOC). Cuenta el número de subclases subordinadas a una clase en la jerarquía, es decir, el número de subclases que pertenecen a una clase. A medida que crece el número de descendientes, se incrementa la reutilización, pero también implica que la abstracción representada por la clase predecesora se ve diluida. Esto dificulta el mantenimiento, ya que existe la posibilidad de que algunos de los descendientes no sean realmente miembros propios de la clase.
       %Number of Children


%\textbf{\emph{\'{I}ndice de especialización por clase.
%(Specialisation Index per Class --SIX-) }}[Lorenz y Kidd, 1994] El
%índice de especialización muestra en que medida las subclases
%redefinen el comportamiento de sus superclases. SIX se propone como
%medida de la calidad en la herencia.

   \item \textbf{Métodos ponderados por clase} (WMC) Dado un peso a cada método en una clase, WMC es el sumatorio todos los pesos de la clase. Se supone que WMC mide la complejidad de una clase, pero si todos los métodos son considerados igualmente complejos (mismo peso), entonces WMS es simplemente el número de métodos definidos en una clase.
       %Weighted Methods per Class

\item \textbf{Falta de cohesión en los métodos} (LCOM). LCOM establece en
        qué medida los métodos hacen referencia a atributos. LCOM es una
        medida de la cohesión de una clase midiendo el número de atributos
        comunes usados por diferentes métodos, indicando la calidad de la
        abstracción hecha en la clase.
        %Lack of Cohesion in Methods

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Resumen %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Resumen}

Al igual que en otros capítulos, la siguiente nube de palabras muestra la importancia relativa
de los conceptos vistos a lo largo de este capítulo.

%\begin{figure}[h!]
%\begin{center}
%    \epsfig{file=WordleCloud-cap5.eps, width=14cm}
%\end{center}
%\label{fig:resumenCap3}
%\end{figure}

En este capítulo hemos definido los conceptos fundamentales de diseño y proporcionado una visión global de los mecanismos y pasos para su realización. Mediante la abstracción, descomposición y modularización, primero se lleva a cabo el \emph{diseño de alto nivel} para después refinarlo en en lo que se conoce como \emph{diseño detallado} de los componentes e interfaces que componen un sistema.

Según han ido evolucionando los lenguajes de programación (no estructurados, estructurados, orientados a objeto) han ido evolucionando las notaciones y técnicas de diseño. Por ejemplo, si bien hoy día es común que un mismo proyecto utilize distintas notaciones, los diagramas de flujo de datos son típicos de los métodos estructurados, los diagramas de clase, de la programación orientadas a objetos, y para el diseño de la base de datos es común utilizar modelos entidad/relación. Por sus peculiaridades, se han comentado aparte el diseño de los sistemas distribuidos y en tiempo real. Además, hemos cubierto brevemente otras técnicas relacionadas con el diseño como son los patrones de diseño, la \emph{refactorización}, \emph{frameworks}, \emph{plug-ins} y el diseño por contratos.

Finalmente, se descrito la los criterios de calidad y técnicas de evaluación del diseño principalmente mediate inspecciones y métricas relevantes al diseño, principalmente como medida de la modularización mediante los conceptos de acoplamiento y cohesión.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Notas Bibliográficas  %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Notas bibliográficas}

Existen literalmente cientos y excelentes de libros cubriendo los aspectos de
diseño tratados en este capitulo tanto en español como en inglés y aunque se intentarán incluir los trabajos seminales y más relevantes siempre se quedarán excelentes obras sin mencionar.

%Entre los trabajos relacionados con la arquitecturas Galan...
%Sobre las arquitecturas, el SEI (Software Engineering Institute),
%mantiene una Web con excelente material: \texttt
%{http://www.sei.cmu.edu/architecture/index.html}
%El estándar IEEE 14171 mantiene información en la Web:
%\texttt{http://www.iso-architecture.org/ieee-1471/}
%%\texttt{http://www.gaudisite.nl/}

Entre los libros cubriendo exclusivamente la fase de diseño, Budgen~\citeyear{Budgen:2003} destaca la importancia del diseño en el contexto global del desarrollo del software y cubre tanto las metodologías estructuradas como las orientadas a objetos (aunque resalta más los métodos estructurados y metodologías tradicionales).

Sobre el diseño utilizando métodos estructurados, las referencias son las de sus autores originales como \cite{Gane:Sarson:1977}, \cite{Jackson:1975}, \cite{Yourdon:1989}, etc. comentadas en el texto pero muchas de ellas resumidas en el libro de Budgen~\citeyear{Budgen:2003}. En cuanto al diseño orientación a objetos, existen literalmente cientos de excelentes referencias siendo de obligada cita la de B.~Meyer~\citeyear{Meyer:1999}. Otras de más reciente publicación y que cubren la ingeniería del software desde el punto de vista de la orientación a objetos podríamos citar a Bruegge y Dutoit~\citeyear{Bruegge:Dutoit:2003}. Además dentro de la orientación a objetos, sobre UML y el proceso unificado son de referencia obligatoria las obras de sus autores originales. G.~Booch~\cite{Booch:EtAl:2005}, J.~Rumbaugh~\citeyear{Rumbaugh:EtAl:2004} e I.~Jacobson~\citeyear{Jacobson:EtAl:1999}. Entre ellos han escrito tres volúmenes: una guía del lenguaje UML, una referencia de UML y el proceso unificado. Otras referencia importante por su sencillez y rápida lectura como introducción a UML es la de M.~Fowler y Kendall \citeyear{Fowler:2004}. La referencia recomendada de OCL es la de Warmer y Kleppe~\citeyear{Warmer:Kleppe:1999}.
%También de los mismos autores, es muy recomendable su trabajo sobre MDA~\cite{}.

El libro de patrones por excelencia y principal fuente de referencia es el de Gamma \emph{et al} \citeyear{Gamma:EtAl:1995}. Otro más recientemente publicado es Larman \citeyear{Larman:2004}. Además existen multitud de sitios Web explicando los patrones principales en diferentes lenguajes de programación. Relacionado con patrones y refactorización la referencia es el libro de Fowler \citeyear{Fowler:2004}.% y la página Web de su autor \texttt{http://www.refactoring.com/}.

Los trabajos originales describiendo \emph{frameworks} son los de Johnson y Foote~\citeyear{Johnson:Foote:1988}, aunque un libro más reciente es de Fayad et al~\citeyear{Fayad:EtAl:1999}.

Dos libros de obligada referencia sobre los sistemas distribuidos son los de Coulouris \emph{et al}~\citeyear{Coulouris:EtAl:2001} y el de Tanenbaum  y van Steen~\citeyear{Tanenbaum:vanSteen:2006}. Ambos libros de docencia cubren todos los aspectos relacionados con los sistemas distribuidos y no solamente el aspecto de diseño.

Finalmente, en cuanto a las métricas y evaluación, nos remitimos a la referencia principal del capítulo de medición \cite{Fenton:Plfeeger:1997}, y a los artículos citados en el texto \cite{Chidamber:Kemerer:1994} y \cite{Brito:Melo:1996}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Cuestiones de autoevaluación %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Cuestiones de autoevaluación}
\label{diseno:cuestiones}

\textbf{C1.} En relación con el polimorfismo, ¿qué se entiende con
la sobrecarga de operadores?

Solución: La sobrecarga de operadores consiste en que se aplica el
mismo operador a distintos tipos de datos, por lo cual la afirmación
es cierta, ya que todos los lenguajes de programación permiten sumar
enteros con enteros, reales con enteros, etc. utilizando el operador
``+''.


\textbf{C2.} ?`Qué diferencia hay entre clase abstracta e interface?

Solución: En una clase abstracta puede haber métodos con
implementación; en una interfaz no.



\textbf{C3.} ?`Qué es un invariante clase?

Solución: Una aserción que siempre es cierta para la clase.


\textbf{C4.} ?`Qué significa que OCL es un lenguaje tipado? ?`Cuáles
son los principales usos de OCL? y?`Porqué un modelo gráfico (como
un diagrama de clases) no es suficiente para lograr una
especificación precisa y no ambigua?


\textbf{C5.} Los invariantes, precondiciones y post-condiciones como
aserciones no deben en los lenguajes de programación no deben
ejecutarse en el código entregado al cliente. Razona el porqué.

Solución: No son código ejecutable, sirven para las pruebas pero no
añaden funcionalidad.


\textbf{C6.} Describe en sentencias breves la diferencia entre
análisis y diseño en la orientación a objetos

Solución: El análisis consiste en encontrar y objetos o conceptos
del dominio de la aplicación, es decir, qué necesita construirse
definiendo el problema y requisitos. El diseño define los objetos y
como estos colaboran, es decir, se concibe una solución al problema.


\textbf{C7.} Las revisiones o inspecciones en de diseño pueden ser
utilizadas para sustituir la fase de pruebas, ?`verdadera o falsa?

Solución: Falso. Las revisiones ayudan a encontrar defectos antes de
que estos pasen a la siguiente fase, pero no son un sustituto.


\textbf{C8.} Queremos ampliar y añadir nuevas funcionalidades a una
clase ya definida sin tener que modificarla. ?`Es posible conseguir
lo que se pide con la programación orientada a objetos?

Respuesta: Si, es posible. El mecanismo a utilizar sería la
herencia. La herencia nos permitirá: (i)$\cdot $ Añadir servicios:
consiste en añadir servicios y atributos nuevos que no estaban
definidos en la superclase. (ii) Implementar servicios: implementar
uno o diversos servicios diferidos de la superclase, siendo los
servicios diferidos aquellos servicios que están definidos pero no
implementados en la superclase, y que en Java se especifican
mediante la cláusula Abstract. (iii) Reimplementar servicios:
consiste en volver a implementar un servicio que ya estaba definido
en la superclase, pero que no nos interesa cómo estaba en la
superclase y que queremos definir de una manera diferente.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ejercicios y actividades propuestos}
\label{diseno:ejercicios}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ejercicios resueltos}
\label{diseno:ejerciciossubsubsec:ejerciciosresueltos}

\textbf{E1. }Comenta el diseno y el codigo de la nota de la
siguiente Figura ?`??. ?`Qué principio se rompe? ?`Cómo se podría
mejorar el diseño?

\begin{figure}[htbp]
\centerline{\includegraphics[width=5.5in,height=4.14in]{./5Diseno/figs/d53.eps}}
\label{fig53}
\end{figure}


\textbf{Solución:} Rompe el principio abierto cerrado. Si se
necesita crear una nueva figura, un \texttt{\textbf{Triángulo}} por
ejemplo, necesitaríamos modificar la función
\texttt{\textbf{drawShape()}}. Además, en una aplicación compleja la
sentencia \texttt{\textbf{switch/case }}se repite una y otra vez
para cada tipo de operación que tenga que realizarse sobre una
figura. Peor aún, cada módulo que contenga este tipo de sentencia
switch/case retiene una dependencia sobre cada posible figura que
haya que dibujar, por lo tanto, cuando se realice cualquier tipo de
modificación sobre una de las figuras, los módulos necesitarán una
nueva compilación y posiblemente una modificación.


Una mejor solución cumpliendo con el principio abierto-cerrado se
muestra en siguiente figura. Las nuevas características pueden
añadirse a la aplicación añadiendo nuevo código en lugar de cambiar
el código en funcionamiento.

\begin{figure}[htbp]
\centerline{\includegraphics[width=5.5in,height=3in]{./5Diseno/figs/d54.eps}}
\label{fig54}
\end{figure}


\textbf{E2}. El siguiente diagrama de clases representa parte del
diseño de una aplicación estadística. En particular, es una parte de
la interfaz de usuario, que representa mediante un diagrama de
barras (clase \texttt{DiagramaBarras}) una serie de datos (pares X e
Y, implementados en la clase \texttt{ListaValores}). El cliente te
pide la inclusión de un nuevo tipo de Diagrama que represente los
datos en forma de ``tarta''. Modifica el diseño para incluir este
cambio, utilizando para ello los patrones de diseño que consideres
necesarios. Si lo necesitas, puedes hacer uso de otros diagramas UML
para explicar el funcionamiento de tu diseño.

\begin{figure}[htbp]
\centerline{\includegraphics[width=4in,height=1.55in]{./5Diseno/figs/d55.eps}}
\label{fig55}
\end{figure}


\textbf{Solución}. Rompe el principio abierto-cerrado, y ademas
vemos este problema tiene una solución por medio de patrón
\emph{Observer}, ya que los diagramas son ``observadores'' de los
datos contenidos en \texttt{ListaValores}.

\begin{figure}[htbp]
\centerline{\includegraphics[width=4in,height=3.75in]{./5Diseno/figs/d56.eps}}
\label{fig56}
\end{figure}


El funcionamiento de la solución propuesta se muestra en el
siguiente diagrama de secuencia. En él se puede ver que ante una
modificación de los datos del sujeto, éste llama al método
``Notificar'', que avisa a todos los observadores registrados de que
ha habido un cambio. Estos posteriormente llaman a la función
``ObtenValor'' para actualizar sus datos y mostrarlos adecuadamente
en el formato correcto.

\begin{figure}[htbp]
\centerline{\includegraphics[width=5in,height=3in]{./5Diseno/figs/d57.eps}}
\label{fig57}
\end{figure}


\textbf{E3}. Una parte de una aplicación de banca \emph{on-line}
permite a sus usuarios gestionar las domiciliaciones de recibos en
sus cuentas, por ejemplo, el pago de los recibos de la compañía que
suministra electricidad a su domicilio. La aplicación permite a los
clientes del banco dar de alta una nueva compañía cuyos recibos
deben ser abonados por el banco y cargados en su cuenta, consultar
la información asociada a los recibos pasados y realizar órdenes de
no-pago sobre una compañía, solicitando al banco que devuelva sin
pagar aquellos recibos que dicha compañía intente cobrar de la
cuenta del cliente. Cuando una compañía de servicios, por ejemplo la
compañía que suministra electricidad, presenta un recibo en el
banco, el banco comprueba que dicha compañía ha sido autorizada por
el cliente para domiciliar pagos en dicha cuenta y si es así, crea
una solicitud de pago desde la cuenta del cliente hasta la cuenta de
la compañía. Dicho pago se hace efectivo en 10 días aproximadamente.
Hasta ese momento la cuenta del usuario no ve decrementado su saldo,
pero el importe correspondiente que se va a transferir no está
disponible y no puede ser utilizado pues se encuentra ``retenido''.
Por ejemplo: Si tenemos 8.500 euros en la cuenta y nos llega un
recibo de gas por un importe de 50 euros, durante el tiempo que
tarda en hacerse efectiva la transferencia seguiremos teniendo 8.500
euros de saldo en nuestra cuenta pero sólo podremos sacar 8.450
euros ya que los otros 50 euros están retenidos a la espera de que
la transferencia se lleve a efecto y se pasen a la cuenta de la
compañía. Hemos dicho que en el momento en que la compañía de
servicios presenta el recibo en el banco, éste crea una solicitud de
pago desde la cuenta del cliente hasta la cuenta de la compañía.
Pues bien, dicha información está durante todo ese tiempo a
disposición del cliente, el cual puede consultarla e incluso dar una
orden de no-pago para ese recibo en concreto. Esta orden de no pago
de un recibo no debe confundirse con la orden de no-pago general
contra una compañía que sería, por ejemplo, ``No cargar en mi cuenta
ningún recibo de Electricidad del Nordeste S.A.''. El diagrama de
los requisitos especificados mediante casos de uso es el de la
siguiente figura.

\begin{figure}[htbp]
\centerline{\includegraphics[width=5.21in,height=3.11in]{./5Diseno/figs/d58.eps}}
\label{fig58}
\end{figure}



Y el caso de uso''Ordenar no pago de un recibo'', cuya descripción
textual es:

\emph{``El usuario selecciona un recibo para devolverlo, lo que
produce la eliminación de la correspondiente solicitud de pago y el
incremento del saldo disponible de la cuenta del usuario en un
importe igual al valor del recibo a devolver''}


\textbf{E3.} Se pide un pequeño \emph{diagrama de clases} con el
\emph{Cliente} como actor, una clase de control que guarda las
opciones de la Interfaz Gráfica de Usuario (GUI), y 2 clases de
entidades Solicitud de Pago y Cuenta


\textbf{Solución}:

\begin{figure}[htbp]
\centerline{\includegraphics[width=4.79in,height=1.36in]{./5Diseno/figs/d59.eps}}
\label{fig59}
\end{figure}




\textbf{E4}. Diagrama de interacción para diagrama el caso de uso
anterior.

\textbf{Solución:}

%\subsubsection{\begin{figure}[htbp]
%\centerline{\includegraphics[width=3.65in,height=2.21in]{./5Diseno/figs/d60.eps}}
%\label{fig60}
%\end{figure}
%}
%\label{subsubsec:mylabel10}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Ejercicios propuestos}

\textbf{E1}. A partir del siguiente diagrama de clases de diseño
para una aplicación de comercio electrónico,

\begin{figure}[htbp]
\centerline{\includegraphics[width=5.6in,height=3in]{./5Diseno/figs/d61.eps}}
\label{fig61}
\end{figure}

Se pide, realizar el bosquejo de un diagrama de secuencia que lleve a cabo la
realización del caso de uso-diseño ``\emph{Preparar pedido}'', que
consiste en validar los elementos del carro de compra y mostrar los
totales en pantalla para solicitar su pago. Implemente sólo el flujo
principal. Supóngase que se han pedido 2 artículos, "El quijote"' y
"100 años de soledad".

\begin{figure}[htbp]
\centerline{\includegraphics[width=6.6in,height=6in]{./5Diseno/figs/d62.eps}}
\label{fig62}
\end{figure}

\textbf{E2.} Una agencia inmobiliaria ``Subprime SA'' desea una
aplicación que guarde información sobre los inmuebles disponibles:
dirección, número de habitaciones, número de baños, y precio. Hay
dos tipos de inmuebles: viviendas y comerciales. Para estos últimos,
los clientes sólo pueden ser empresas. Los clientes de Subprime
solicitan consultas indicando el área (zona) y rango de precios
deseados, y el sistema muestra los inmuebles disponibles. Las áreas
se indican por ciudad y cada ciudad tiene unas subáreas (barrios).
De los clientes se guarda el nombre y teléfono, y las zonas se
expresan diciendo el barrio dentro de la ciudad que les interesa.

El sistema registra todas las consultas de los clientes, y los pisos que han
visitado. Si un cliente (particular o empresa) compra el inmueble, y
comprando el inmueble, con un precio final.

Dibuja un diagrama de clases de la especificación, con sus
atributos.

\begin{figure}%[htbp]
\centerline{\includegraphics[width=5.71in,height=5.21in]{./5Diseno/figs/d63.eps}}
\label{fig63}
\end{figure}

\textbf{E3}. Una Facultad de Informática ha acordado elaborar un
sistema para que se mantenga la contabilidad de la asistencia de sus
estudiantes a actividades extra-curriculares (conferencias, charlas,
concursos, etc.). El objeto de este sistema es que la asistencia a
esas actividades le reporte al alumno la oportunidad de ser
consideradas como créditos de libre elección dentro de su
titulación.

Los créditos se contabilizarán al final del curso académico, y al
principio del siguiente, se aprobará la lista de actividades que les
permite obtener ese tipo de créditos.

Cada actividad tendrá una denominación, una breve descripción, y un
responsable, que será un profesor de un Departamento. De los
profesores se conocerá su nombre, DNI, email y como dirección se
usará la del Departamento.

Las actividades tendrán una fecha de inicio y final, y para cada una
de ellas, se deberá especificar cuántos créditos supone para alumnos
de determinadas carreras. Es decir, se da la posibilidad, por
ejemplo, de que una misma actividad reporte a un alumno de
``Empresariales'' 0,5 créditos, mientras que a un alumno de
``Ingeniería Informática'' le aporte 0,75.

Habrá dos tipos de actividades: de presencia controlada o de
tutorización. En las primeras, el estudiante adquirirá los créditos
por la asistencia a la actividad programada simplemente, y lo único
que se requiere es indicar qué medio de control se utilizará (uno de
los siguientes: hojas de firmas o control por carné universitario).
En el segundo, el estudiante tendrá que ser examinado o evaluado por
un profesor o varios para determinar si cumple o no los requisitos
para otorgarle los créditos.

El número de profesores tutores por alumno se especificará para cada
actividad. Esta evaluación requiere que los profesores que evalúan a
cada estudiante queden registrados, ante la posibilidad de
reclamaciones.

Además, para hacer el cálculo de los créditos asignados, se necesita
un registro de la asistencia de los estudiantes a las actividades.
Existe la posibilidad de que se considere que un estudiante ha
``asistido'' sólo a un porcentaje de una actividad. Por ejemplo, que
haya asistido a dos sesiones de tres en un ciclo de conferencias. En
este caso, los créditos que proporciona la actividad se dividirán
oportunamente.


Un diagrama de clases UML que modele el problema anterior. No es
necesario especificar las operaciones, pero sí las clases, sus
atributos y las relaciones entre las clases.

\begin{figure}[htbp]
\centerline{\includegraphics[width=5.69in,height=5.40in]{./5Diseno/figs/d64.eps}}
\label{fig64}
\end{figure}


\textbf{E4}. El estado de Gotham ha aprobado recientemente la
creación de una nueva Universidad para su capital, Gotham City. La
Universidad comenzará a ofrecer estudios en el curso académico
2007/08, por lo que durante el curso 2006/07 solamente hará estudios
del mercado formativo al que se enfrenta. En esa primera fase, la
Universidad recogerá información a través de su Web sobre las
titulaciones en las que estaría interesado cursar los potenciales
alumnos que entren en la página de la Universidad. De esos alumnos
se registrará su dirección completa para enviarles información por
correo electrónico en el futuro. También se debe guardar en qué
titulaciones de entre las existentes están interesados, y el modo de
acceso que utilizarán en los estudios superiores. Estos modos de
acceso pueden ser uno de los siguientes: mayores de 45 años, para
personas con estudios básicos que superen esa edad; titulados, para
aquellos que ya tienen titulación superior y extranjeros, para
personas que tienen un grado básico de formación en un país
extranjero. En el caso de los mayores de 45 años, se debe guardar su
fecha de nacimiento. En el caso de los ya titulados, se tiene que
saber qué titulación es la que tienen y en qué año la obtuvo. En el
caso de extranjeros, hay que guardar la nacionalidad de los mismos.

Además de todo lo anterior, la aplicación debe registrar los
mensajes de email promocionales que se enviarán a los estudiantes,
guardando su fecha de envió, el tema (subject), la titulación de la
que se enviaron datos promocionales y si el estudiante respondió o
no.

Dibujar un diagrama de clases:

%\subsubsection{\begin{figure}[htbp]
%\centerline{\includegraphics[width=5.65in,height=3.49in]{./5Diseno/figs/d65.eps}}
%\label{fig65}
%\end{figure}
%}
%\label{subsubsec:mylabel11}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Actividades propuestas}

\textbf{E1.} El paquete \texttt{JHotDraw},
\texttt{http://www.jhotdraw.org/} esta realizado teniendo en cuenta
mucho patrones de diseño. Se propone leer el material que los
autores suministran en la página Web y analizar el código de
\texttt{JHotDraw}.

\textbf{E2.} Los fallos de Therac 25 están principalmente
relacionados con el diseño. Lee el artículo de Levenson, N. y Turner
C. ``An Investigation of the Therac-25 Incidents'', IEEE Computer
26(7), pp. 18-41.

\textbf{E3}. Analiza los mecanismos que ofrecen algunos lenguajes
populares (por ejemplo, Java, C++, Phyton) en el soporte del diseño
por contratos (invariantes, pre- y post-condiciones). Compáralos con
los mecanismos ofrecidos por Eiffel.

\textbf{E4.} Analiza la herramienta Architecture Expert (ArchE) y
sus posibilidades analizando y comparando distintas arquitecturas.

Utiliza la herramienta Dependency Finder para analizar las dependicas de un paquete java de código abierto (\texttt{http://depfind.sourceforge.net/}).

\textbf{E5.} Busca bibliografía sobre como UML se ha extendido a
dominios específicos, por ejemplo para tiempo real.

\textbf{E6.} Hay herramientas que generan aserciones a partir del
lenguaje OCL. Encuentra alguna y ejecuta algunos de los ejemplos que
vienen con ellas.



